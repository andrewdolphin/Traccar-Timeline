<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Traccar Timeline</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css">
<style>

:root {
  /* Base Theme Colors */
  --bg-primary: rgba(255, 255, 255, 0.95);
  --bg-secondary: #f5f5f5;
  --bg-tertiary: #e0e0e0;
  
  --text-primary: #333333;
  --text-secondary: #666666;
  --text-tertiary: #999999;
  
  --border-color: #dddddd;
  --border-color-hover: #999999;
  
  /* Accent Colors (User Customizable) */
  --accent-fg: #4ECDC4;
  --accent-bg: #2A9D8F;
  --accent-fg-10: rgba(78, 205, 196, 0.1);
  --accent-fg-20: rgba(78, 205, 196, 0.2);
  --accent-fg-30: rgba(78, 205, 196, 0.3);
  --accent-bg-10: rgba(42, 157, 143, 0.1);
  --accent-bg-20: rgba(42, 157, 143, 0.2);
  --accent-bg-30: rgba(42, 157, 143, 0.3);
  
  /* Button Colors */
  --btn-primary-bg: var(--accent-fg);
  --btn-primary-hover: var(--accent-bg);
  --btn-secondary-bg: #6c757d;
  --btn-secondary-hover: #5a6268;
  --btn-remove-bg: #dc3545;
  --btn-remove-hover: #c82333;
  
  /* Timeline Specific */
  --timeline-bg: var(--bg-secondary);
  --timeline-border: var(--border-color);
  --timeline-period-even: rgba(0, 0, 0, 0.03);
  --timeline-period-odd: rgba(0, 0, 0, 0.06);
  --timeline-scrubber: rgba(0, 0, 0, 0.6);
  
  /* Modal & Overlay */
  --modal-overlay: rgba(0, 0, 0, 0.5);
  --modal-bg: var(--bg-primary);
  --modal-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
  
  /* Input & Form Elements */
  --input-bg: var(--bg-primary);
  --input-border: var(--border-color);
  --input-text: var(--text-primary);
  --input-placeholder: var(--text-tertiary);
  
  /* Spacing */
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 12px;
  --spacing-lg: 16px;
  --spacing-xl: 24px;
  
  /* Border Radius */
  --radius-sm: 3px;
  --radius-md: 5px;
  --radius-lg: 8px;
  
  /* Transitions */
  --transition-fast: 0.15s ease;
  --transition-normal: 0.2s ease;
  --transition-slow: 0.3s ease;
  
  /* Z-index layers */
  --z-timeline: 1000;
  --z-legend: 1000;
  --z-dropdown: 1001;
  --z-scrubber: 10;
  --z-error: 10000;
  --z-modal: 10001;
  --z-color-editor: 10002;
  
  /* Dark mode overlay color */
  --dark-bg-rgb: rgba(42, 42, 42, 0.95);
}

/* Dark Mode Overrides */
body.dark-mode {
  --bg-primary: rgba(26, 26, 26, 0.95);
  --bg-secondary: #2a2a2a;
  --bg-tertiary: #3a3a3a;
  
  --text-primary: #e0e0e0;
  --text-secondary: #aaaaaa;
  --text-tertiary: #888888;
  
  --border-color: #444444;
  --border-color-hover: #666666;
  
  --btn-primary-bg: var(--accent-bg);
  --btn-primary-hover: var(--accent-fg);
  --btn-secondary-bg: #5a6268;
  --btn-secondary-hover: #545b62;
  --btn-remove-bg: #dc3545;
  --btn-remove-hover: #c82333;
  
  --timeline-bg: #1a1a1a;
  --timeline-border: var(--border-color);
  --timeline-period-even: rgba(255, 255, 255, 0.02);
  --timeline-period-odd: rgba(255, 255, 255, 0.05);
  --timeline-scrubber: rgba(255, 255, 255, 0.8);
  
  --modal-bg: var(--bg-secondary);
  
  --input-bg: #1a1a1a;
  --input-border: var(--border-color);
  --input-text: var(--text-primary);
  
  --legend-hover: #3a3a3a;
}

/* ============================================================================
   BASE STYLES
   ============================================================================ */
* { box-sizing: border-box; }

html, body { 
  height: 100vh; /* Fallback for older browsers */
  height: 100dvh;
  width: 100vw;
  width: 100dvw;
  margin: 0; 
  padding: 0; 
  font-family: 'Segoe UI', sans-serif; 
  font-size: 16px;
  /* overflow: hidden; */
  position: fixed;
}

body {
  position: relative;
}

body.dark-mode {
  background: var(--bg-primary);
  color: var(--text-primary);
}

body.modal-open {
  overflow: hidden;
}

#map { 
  height: 100vh; /* Fallback for older browsers */
  height: 100dvh;
  width: 100vw;
  width: 100dvw;
  position: fixed;
  top: 0;
  left: 0;
  z-index: 0;
}


.leaflet-popup-content-wrapper, .leaflet-popup-tip {
  background: var(--bg-primary);
  color: var(--text-primary);
}

.map-popup {
  min-width: 220px;
  font-family: "Segoe UI", sans-serif;
  --device-color: #999;
}

.popup-header {
  padding-bottom: 6px;
  margin-bottom: 8px;
}

.popup-title {
  font-size: 15px;
}

.popup-divider {
  height: 2px;
  background: var(--device-color);
  margin-top: 4px;
}

.popup-time {
  font-size: 11px;
  margin-bottom: 8px;
}

.popup-time-ago {
  color: #666;
}

.popup-section {
  margin-bottom: 6px;
}

.popup-motion {
  margin-bottom: 2px;
}

.popup-arrow {
  font-size: 16px;
  margin-right: 4px;
}

.popup-battery.ok strong {
  color: #28a745;
}

.popup-battery.low strong {
  color: #dc3545;
}

.popup-address {
  border-left: 3px solid var(--device-color);
  border-radius: 3px;
  padding-left: 8px;
  margin-top: 6px;
}

/* Device name tooltips */
.device-name-tooltip {
  background: rgba(0, 0, 0, 0.75);
  border: 1px solid rgba(255, 255, 255, 0.3);
  color: white;
  font-size: 11px;
  font-weight: 600;
  padding: 2px 6px;
  border-radius: 3px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
  white-space: nowrap;
}

.device-name-tooltip::before {
  display: none; /* Hide the default arrow */
}

.map-marker-details{
  background-color: #99999923;
  font-size: 0.6875rem; /* 11px */
  margin: 2px 0;
  padding: 6px;
}

#legend {
  position: absolute;
  top: 10px;
  left: 10px;
  min-width: 180px;
  z-index: var(--z-legend);
  background: var(--bg-primary);
  padding: 10px;
  border-radius: var(--radius-md);
  box-shadow: var(--modal-shadow);
  height: calc(100% - (var(--timeline-height, 150px) + 20px));
  transition: height 0.3s ease;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

#legend.collapsed {
  height: auto;
}

.legend-header {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: bold;
  font-size: 0.875rem; /* 14px - increased from 13px */
}

.legend-toggle {
  background: none;
  border: none;
  cursor: pointer;
  font-size: 1rem; /* 16px - increased from 14px */
  padding: 4px;
  line-height: 1;
  flex-shrink: 0;
  /* min-width: 2.5rem;
  min-height: 2.5rem; */
}

.legend-devices-label {
  flex-shrink: 0;
}

#legend-search {
  flex: 1;
  padding: var(--spacing-sm) var(--spacing-sm);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-sm);
  background: var(--bg-secondary);
  color: white;
  font-size: 0.875rem;
  outline: none;
  transition: border-color var(--transition-fast);
  min-height: 32px;
}

#legend-search:focus {
  border-color: var(--accent-fg);
}

#legend-search::placeholder {
  color: var(--text-tertiary);
}

.legend-items {
  overflow-y: auto;
  flex: 1;
  min-height: 0;
}

#legend.collapsed .legend-items {
  display: none;
}

.legend-item {
  display: flex;
  align-items: center;
  margin-bottom: var(--spacing-xs);
  cursor: pointer;
  padding: 6px;
  border-radius: var(--radius-sm);
  transition: background var(--transition-normal);
  font-size: 0.875rem;
}

.legend-item:first-child {
  margin-top: var(--spacing-sm);
}

.legend-item:hover {
  background: var(--legend-hover);
}

.legend-item.disabled {
  opacity: 0.5;
}

.legend-item.disabled .color-box {
  background: #999 !important;
}

.legend-item.inactive {
  opacity: 0.5;
}

.legend-item.inactive .color-box {
  background: #999 !important;
}

.legend-item-name {
  flex: 1;
  margin-right: 8px;
}

.legend-item-status {
  font-size: 0.75rem; /* 12px - increased from 10px */
  color: #666;
  white-space: nowrap;
}

.status-indicator {
  display: inline-block;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  margin-right: 4px;
}

.color-box {
  width: 12px;
  height: 12px;
  margin-right: 6px;
  border-radius: 2px;
}

#timeline-container {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  background: var(--bg-primary);
  z-index: var(--z-timeline);
  display: flex;
  flex-direction: column;
  padding: var(--spacing-sm) var(--spacing-md) var(--spacing-md) var(--spacing-md);
  box-shadow: 0 -2px 6px rgba(0,0,0,0.2);
}

#timeline-title {
  text-align: center;
  font-weight: 600;
  font-size: 0.875rem;
  color: var(--text-primary);
  margin-bottom: var(--spacing-sm);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

#timeline-title-left {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  flex: 1;
}

#timeline-title-left #settings-btn {
  font-size: 1rem;
  padding: 6px 10px;
  min-height: auto;
}

#timeline-title-center {
  flex: 2;
  text-align: center;
}

#timeline-title-right {
  flex: 1;
  display: flex;          
  justify-content: flex-end; 
  align-items: center;     
}

.timeline-collapse-btn {
  background: none;
  border: none;
  cursor: pointer;
  font-size: 1.125rem; /* 18px - increased from 16px */
  padding: 6px;
  line-height: 1;
}

#timeline-controls {
  display: flex;
  gap: 8px;
  align-items: center;
}

#timeline-wrapper {
  position: relative;
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

#timeline {
  position: relative;
  width: 100%;
  background: var(--timeline-bg);
  border-radius: var(--radius-sm);
  border: 1px solid var(--timeline-border);
  user-select: none;
  max-height: 85px;
  min-height: fit-content;
  overflow-y: auto;
  overflow-x: hidden;
  cursor: crosshair;
  display: flex;
}

#timeline.collapsed {
  max-height: none;
  overflow: hidden;
}

/* NEW: Timeline layout with separate label column */
#timeline-labels-column {
  flex-shrink: 0;
  width: 100px;
  background: rgba(255, 255, 255, 0.5);
  border-right: 1px solid var(--border-color);
  padding: var(--spacing-xs) 0;
  display: flex;
  flex-direction: column;
  gap: 2px;
}

/* Hide labels column when timeline is collapsed */
#timeline-labels-column.collapsed {
  display: none;
}

body.dark-mode #timeline-labels-column {
  background: rgba(42, 42, 42, 0.5);
}

#timeline-devices {
  position: relative;
  flex: 1;
  min-height: 30px;
  padding: 4px 0;
  display: flex;
  flex-direction: column;
  gap: 2px;
}

body.dark-mode .timeline-device-row {
  background: rgba(42, 42, 42, 0.8);
}
.timeline-device-row {
  position: relative;
  min-height: 1.5rem; /* Match timeline-device-name min-height for alignment */
  display: flex;
  align-items: center;
  background: rgba(255, 255, 255, 0.9);
}



.timeline-device-row:last-child {
  margin-bottom: 0;
}

/* Hide individual device rows when timeline is collapsed */
.timeline-device-row.collapsed {
  display: none;
}

/* Amalgamated row shown in collapsed state */
.timeline-amalgamated-row {
  position: relative;
  min-height: 1.5rem;
  display: none;
  align-items: center;
}

.timeline-amalgamated-row.visible {
  display: flex;
}

/* NEW: Label in separate column */
.timeline-device-name {
  font-size: 0.6875rem; /* 11px - increased from 9px */
  font-weight: 500;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  padding: 2px 6px;
  border-radius: 2px;
  background: rgba(255, 255, 255, 0.9);
  transition: background 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  min-height: 1.5rem; /* Better tap target */
}

.timeline-device-name:hover {
  background: rgba(255, 255, 255, 1);
}

body.dark-mode .timeline-device-name {
  background: rgba(42, 42, 42, 0.9);
}

body.dark-mode .timeline-device-name:hover {
  background: rgba(42, 42, 42, 1);
}

.timeline-device-name.disabled {
  opacity: 0.4;
  text-decoration: line-through;
}

.timeline-device-tracks {
  position: relative;
  width: 100%;
  height: 100%;
}

.timeline-device-tracks.disabled {
  opacity: 0.4;
}

.timeline-period {
  position: absolute;
  top: 0;
  height: 100%;
  pointer-events: none;
  z-index: 1;
}

.timeline-period.even {
  background: var(--timeline-period-even);
}

.timeline-period.odd {
  background: var(--timeline-period-odd);
}

.timeline-selection {
  position: absolute;
  top: 0;
  height: 100%;
  background: var(--accent-fg-20);
  border-left: 2px solid var(--accent-fg);
  border-right: 2px solid var(--accent-fg);
  pointer-events: none;
  z-index: 5;
}

body.dark-mode .timeline-selection {
  background: var(--accent-bg-30);
  border-color: var(--accent-bg);
}

/* FIXED: Scrubber styling */
.timeline-scrubber {
  position: absolute;
  top: 0;
  width: 2px;
  height: 100%;
  background: var(--timeline-scrubber);
  pointer-events: none;
  z-index: var(--z-scrubber);
  left: -2px;
  opacity: 0;
  transition: opacity var(--transition-fast);
}

.timeline-scrubber.visible {
  opacity: 1;
}

.timeline-scrubber.selecting {
  background: var(--accent-fg-30);
  border-left: 2px solid var(--accent-fg);
  border-right: 2px solid var(--accent-fg);
}

body.dark-mode .timeline-scrubber.selecting {
  background: var(--accent-bg-30);
  border-color: var(--accent-bg);
}

.timeline-scrubber.locked {
  background: var(--accent-fg);
  width: 3px;
  z-index: 11;
  opacity: 1;
}

body.dark-mode .timeline-scrubber.locked {
  background: var(--accent-bg);
}

.timeline-labels {
  height: 20px;
  width: 100%;
  pointer-events: none;
  position: relative;
  margin-left: 100px; /* Match label column width */
}

.timeline-tick-label {
  position: absolute;
  font-size: 0.75rem; /* 12px - increased from 10px */
  color: #666;
  white-space: nowrap;
  max-width: 80px;
  overflow: hidden;
  text-overflow: ellipsis;
  pointer-events: none;
  z-index: 1000;
}

body.dark-mode .timeline-tick-label {
  color: #aaa;
}

.timeline-tick-label.first {
  transform: none;
  left: 0 !important;
}

.timeline-tick-label.last {
  transform: translateX(-100%);
  left: calc(100% - 100px)  !important;
}

.timeline-tick-label.middle {
  transform: translateX(-50%);
}

.timeline-track {
  position: absolute;
  height: 1em;
  border-radius: 2px;
  opacity: 0.8;
  transition: opacity 0.2s;
  z-index: 3;
  top: 50%;
  transform: translateY(-50%);  
}

.timeline-track:hover {
  opacity: 1;
}

.timeline-track.highlighted {
  opacity: 1;
  box-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
  z-index: 4;
}

body.dark-mode .timeline-track.highlighted {
  box-shadow: 0 0 8px rgba(0, 0, 0, 0.8);
}

.timeline-row-bg {
  position: absolute;
  left: 0;
  right: 0;
  height: 10px;
  background: rgba(0, 0, 0, 0.02);
  z-index: 2;
}

body.dark-mode .timeline-row-bg {
  background: rgba(255, 255, 255, 0.03);
}

#time-selector {
  position: absolute;
  top: 10px;
  right: 10px;
  z-index: var(--z-timeline);
  background: var(--bg-primary);
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--radius-md);
  box-shadow: var(--modal-shadow);
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
  align-items: stretch;
}

#time-selector select {
  padding: 6px 10px;
  border: 1px solid var(--border-color);
  border-radius: var(--radius-sm);
  font-size: 0.875rem;
  cursor: pointer;
  background: var(--bg-tertiary);
  color: var(--text-primary);
  min-height: 2.5rem;
}

#time-selector button {
  width: 100%;
}

#custom-time {
  display: none;
  position: absolute;
  top: 50px;
  right: 10px;
  z-index: var(--z-dropdown);
  background: var(--bg-primary);
  padding: 10px;
  border-radius: var(--radius-md);
  box-shadow: var(--modal-shadow);
  font-size: 0.875rem;
}

#custom-time input {
  display: block;
  margin: var(--spacing-xs) 0;
  padding: 6px;
  border: 1px solid var(--border-color);
  border-radius: var(--radius-sm);
  font-size: 0.875rem;
  background: var(--input-bg);
  color: var(--input-text);
  min-height: 2.5rem;
  width: 100%;
}

#custom-time label {
  display: block;
  margin-top: 6px;
  font-weight: 500;
}

/* Standardized Button Classes */
.primary {
  padding: var(--spacing-sm) var(--spacing-md);
  background: var(--btn-primary-bg);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  cursor: pointer;
  font-size: 0.875rem;
  min-height: 2.5rem;
  transition: background var(--transition-normal);
}

.primary:hover {
  background: var(--btn-primary-hover);
}

.secondary {
  padding: var(--spacing-sm) var(--spacing-md);
  background: var(--btn-secondary-bg);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  cursor: pointer;
  font-size: 0.875rem;
  transition: background var(--transition-normal);
}

.secondary:hover {
  background: var(--btn-secondary-hover);
}

.remove {
  padding: 6px 10px;
  background: var(--btn-remove-bg);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  cursor: pointer;
  font-size: 0.75rem;
  transition: background var(--transition-normal);
}

.remove:hover {
  background: var(--btn-remove-hover);
}

#settings-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--modal-overlay);
  z-index: var(--z-modal);
  justify-content: center;
  align-items: center;
}

#settings-content {
  background: var(--modal-bg);
  border-radius: var(--radius-lg);
  box-shadow: var(--modal-shadow);
  min-width: 600px;
  max-width: 800px;
  max-height: 90vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

#settings-content h3 {
  position: sticky;
  top: 0;
  background: var(--modal-bg);
  padding: var(--spacing-xl) var(--spacing-xl) var(--spacing-sm) var(--spacing-xl);
  margin: 0;
  z-index: 10;
  border-radius: var(--radius-lg) var(--radius-lg) 0 0;
}
#settings-content p.settings-description {
  font-size: 0.8125rem; 
  color: #666;
  margin-top:0;
}
#settings-content > p {
  padding: 0 var(--spacing-xl);
  margin-top: 8px;
  margin-bottom: var(--spacing-md);
}

.settings-columns {
  flex: 1;
  overflow-y: auto;
  padding: 0 var(--spacing-xl) var(--spacing-md) var(--spacing-xl);
}

#settings-content .dialog-actions {
  position: sticky;
  bottom: 0;
  background: var(--modal-bg);
  padding: var(--spacing-md) var(--spacing-xl) var(--spacing-xl) var(--spacing-xl);
  margin: 0;
  border-top: 1px solid var(--border-color);
  z-index: 10;
  border-radius: 0 0 var(--radius-lg) var(--radius-lg);
}

.settings-columns {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
}

.setting-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.setting-row label {
  font-weight: 500;
}

.setting-row select {
  padding: 4px 8px;
  border: 1px solid #ddd;
  border-radius: 3px;
  background: white;
  color: #333;
}

body.dark-mode .setting-row select {
  background: #1a1a1a;
  color: #e0e0e0;
  border-color: #444;
}

.settings-group {
  margin: 10px 0;
}

.settings-group select {
  width: 100%;
  padding: 6px 10px;
  border: 1px solid var(--border-color);
  border-radius: var(--radius-sm);
  font-size: 0.875rem;
  cursor: pointer;
  background: var(--bg-tertiary);
  color: var(--text-primary);
}

.settings-group label {
  display: block;
  margin-bottom: var(--spacing-xs);
  font-weight: 500;
  font-size: 0.875rem;
}

.settings-group input[type="text"],
.settings-group input[type="number"],
.settings-group input[type="password"] {
  width: 100%;
  padding: 6px var(--spacing-sm);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-sm);
  font-size: 0.875rem;
  background: var(--input-bg);
  color: var(--input-text);
}

.color-picker-wrapper {
  display: flex;
  align-items: center;
  gap: 8px;
}

.color-picker-wrapper input[type="color"] {
  width: 50px;
  height: 30px;
  border: 1px solid var(--border-color);
  border-radius: var(--radius-sm);
  cursor: pointer;
}

.color-picker-wrapper input[type="text"] {
  flex: 1;
  padding: 6px var(--spacing-sm);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-sm);
  font-family: monospace;
  background: var(--input-bg);
  color: var(--input-text);
}

.palette-manager {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
  gap: 8px;
}

.palette-color-swatch {
  width: 50px;
  height: 50px;
  border-radius: 4px;
  cursor: pointer;
  border: 2px solid transparent;
  transition: all 0.2s;
  position: relative;
}

.palette-color-swatch:hover {
  border-color: #333;
  transform: scale(1.05);
}

body.dark-mode .palette-color-swatch:hover {
  border-color: #ccc;
}

.palette-item {
  display: flex;
  align-items: center;
  gap: 8px;
}

.palette-item input[type="color"] {
  width: 40px;
  height: 30px;
  border: 1px solid #ddd;
  border-radius: 3px;
  cursor: pointer;
}

.palette-item input[type="text"] {
  flex: 1;
  padding: 6px 8px;
  border: 1px solid #ddd;
  border-radius: 3px;
  font-family: monospace;
  font-size: 0.75rem;
}

body.dark-mode .palette-item input[type="text"] {
  background: #1a1a1a;
  color: #e0e0e0;
  border-color: #444;
}

/* Color Editor Modal */
#color-editor-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--modal-overlay);
  z-index: var(--z-color-editor);
  justify-content: center;
  align-items: center;
}

#color-editor-content {
  background: var(--modal-bg);
  padding: var(--spacing-lg);
  border-radius: var(--radius-lg);
  box-shadow: var(--modal-shadow);
  min-width: 300px;
}

.color-editor-preview {
  width: 100%;
  height: 60px;
  border-radius: var(--radius-sm);
  margin: 10px 0;
  border: 2px solid var(--border-color);
}

.color-editor-input-group {
  display: flex;
  gap: var(--spacing-sm);
  align-items: center;
  margin-bottom: 15px;
}

.color-editor-picker {
  width: 60px;
  height: 40px;
  border: 1px solid var(--border-color);
  border-radius: var(--radius-sm);
  cursor: pointer;
  padding: 2px;
}

.color-editor-input {
  flex: 1;
  padding: var(--spacing-sm);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-sm);
  font-family: monospace;
  font-size: 1rem;
  background: var(--input-bg);
  color: var(--input-text);
}

.dialog-actions {
  display: flex;
  gap: 8px;
  justify-content: space-between;
}

.dialog-actions-right {
  display: flex;
  gap: 8px;
  flex: 1;
  display: flex;           /* add this */
  justify-content: flex-end; /* push children to the right */
  align-items: center;      /* optional, vertically center buttons */  
}

.dialog-actions button {
  min-width: 80px;
}

.credentials-group {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-top: 8px;
}

.import-export-group {
  display: flex;
  gap: 8px;
  margin-top: 12px;
  grid-column: 1 / -1;
}

.import-export-group button {
  flex: 1;
}

/* Position Leaflet controls above the timeline */
.leaflet-bottom {
  position: absolute;
  bottom: var(--timeline-height, 150px) !important;
  transition: bottom 0.3s ease;
}

/* Add padding to ensure controls don't overlap with timeline */
.leaflet-bottom.leaflet-right {
  margin-bottom: 10px;
}

#error-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--modal-overlay);
  z-index: var(--z-error);
  justify-content: center;
  align-items: center;
}
#error-notification li {
    line-height: 2em;}

#error-notification {
  background: var(--modal-bg);
  border-radius: var(--radius-lg);
  box-shadow: var(--modal-shadow);
  min-width: 600px;
  max-width: 800px;
  max-height: 90vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

#error-notification h3 {
  position: sticky;
  top: 0;
  background: var(--modal-bg);
  padding: var(--spacing-xl) var(--spacing-xl) var(--spacing-sm) var(--spacing-xl);
  margin: 0;
  z-index: 10;
  border-radius: var(--radius-lg) var(--radius-lg) 0 0;
}

#error-notification > p {
  flex: 1;
  overflow-y: auto;
  padding: var(--spacing-md) var(--spacing-xl);
  margin: 0;
}

#error-notification .dialog-actions {
  position: sticky;
  bottom: 0;
  background: var(--modal-bg);
  padding: var(--spacing-md) var(--spacing-xl) var(--spacing-xl) var(--spacing-xl);
  margin: 0;
  border-top: 1px solid var(--border-color);
  z-index: 10;
  border-radius: 0 0 var(--radius-lg) var(--radius-lg);
}

.config-badge {
  display: inline-block;
  background-color: var(--bg-primary);
  color: var(--accent-fg);
  font-family: monospace;
  font-size: 0.875rem;
  padding: 2px 6px;
  border-radius: var(--radius-lg);
  margin-left: 4px;
  border: 1px solid var(--accent-fg);
  box-shadow:  var(--modal-shadow);
}

/* ============================================================================ */
/* CUSTOM MAP CONTROLS - Theme-aware */
/* ============================================================================ */

/* Override default Leaflet controls to match theme */
.leaflet-control-zoom,
.leaflet-control-layers, .leaflet-control {
  border: none !important;
  box-shadow: var(--modal-shadow) !important;
}

.leaflet-control-zoom a,
.leaflet-bar a {
  background-color: var(--bg-primary) !important;
  color: var(--text-primary) !important;
  border: 1px solid var(--border-color) !important;
  transition: all var(--transition-fast) !important;
}

.leaflet-control-zoom a:hover,
.leaflet-bar a:hover {
  background-color: var(--bg-secondary) !important;
  border-color: var(--accent-fg) !important;
  color: var(--accent-fg) !important;
}

/* Custom layer switcher control */
.custom-layer-control {
  position: relative;
}

.layer-toggle-btn {
  width: 30px;
  height: 30px;
  background-color: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-sm);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  color: var(--text-primary);
  transition: all var(--transition-fast);
  box-shadow: var(--modal-shadow);
}

.layer-toggle-btn:hover {
  background-color: var(--bg-secondary);
  border-color: var(--accent-fg);
  color: var(--accent-fg);
}

.layer-menu {
  position: absolute;
  bottom: 100%;
  right: 0;
  margin-bottom: 5px;
  background-color: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-md);
  box-shadow: var(--modal-shadow);
  padding: 8px 0;
  min-width: 120px;
  display: none;
  z-index: 1000;
}

.layer-menu.show {
  display: block;
}

.layer-menu-item {
  padding: 8px 16px;
  cursor: pointer;
  color: var(--text-primary);
  font-size: 13px;
  transition: all var(--transition-fast);
  white-space: nowrap;
}

.layer-menu-item:hover {
  background-color: var(--bg-secondary);
}

.layer-menu-item.active {
  font-weight: 700;
  color: var(--accent-fg);
  background-color: var(--accent-fg-10);
}

/* Winter theme CSS filter for map tiles - only affects base pane, not overlay pane */
.leaflet-base-pane.winter-filter {
  filter: brightness(1.1) contrast(1) saturate(0.3) hue-rotate(140deg);
  transition: filter 0.3s ease;
}

/* Layer menu separator */
.layer-menu-separator {
  height: 1px;
  background-color: var(--border-color);
  margin: 8px 0;
}

.layer-menu-section-label {
  padding: 4px 16px;
  font-size: 11px;
  font-weight: 600;
  color: var(--text-tertiary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* ============================================================================ */
/* MOBILE RESPONSIVE STYLES */
/* ============================================================================ */

@media (max-width: 768px) {
  .settings-columns {
    grid-template-columns: 1fr;
    gap: 0;
  }

  #settings-content {
    min-width: unset;
    width: 100%;
    height: 100vh;
    height: 100dvh;
    max-height: 100vh;
    max-height: 100dvh;
    border-radius: 0;
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  #settings-content h3 {
    position: sticky;
    top: 0;
    background: var(--modal-bg);
    padding: var(--spacing-md) 0 0 var(--spacing-lg);
    margin: 0;
    z-index: 10;
    /* border-bottom: 1px solid var(--border-color); */
  }

  #settings-content > p {
    padding: 0 var(--spacing-lg);
  }

  #settings-content .settings-columns {
    flex: 1;
    overflow-y: auto;
    padding: 0 var(--spacing-lg) var(--spacing-lg) var(--spacing-lg);
  }

  #settings-content .dialog-actions {
    position: sticky;
    bottom: 0;
    background: var(--modal-bg);
    padding: var(--spacing-md) var(--spacing-lg);
    margin: 0;
    border-top: 1px solid var(--border-color);
    z-index: 10;
  }

  #settings-modal {
    padding: 0;
    align-items: stretch;
  }

  /* Make all settings groups within columns display in 2-column grid on mobile */
  .settings-columns > div {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }

  /* Settings rows that contain two settings-group children should span 2 columns and display as grid */
  .settings-row {
    grid-column: 1 / -1;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }

  /* Full-width exceptions for certain settings */
  .settings-columns > div > .settings-group:first-child,
  .settings-columns > div > .settings-group:has(#theme-select),
  .settings-columns > div > .settings-group:has(#realtime-hours),
  .settings-columns > div > .settings-group:has(#show-direction-arrows),
  .settings-columns > div > .settings-group:has(#arrow-spacing),
  .settings-columns > div > .settings-group:has(#palette-manager) {
    grid-column: 1 / -1;
  }

  .settings-group {
    margin: 5px 0;
  }

  #color-editor-content {
    width: 90vw;
    max-width: 400px;
  }

  .palette-manager {
    grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
  }

  .palette-color-swatch {
    width: 40px;
    height: 40px;
  }

  /* Mobile: Error modal full screen */
  #error-modal {
    padding: 0;
    align-items: stretch;
  }

  #error-notification {
    min-width: unset;
    width: 100%;
    height: 100vh;
    height: 100dvh;
    max-height: 100vh;
    max-height: 100dvh;
    border-radius: 0;
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  #error-notification h3 {
    position: sticky;
    top: 0;
    background: var(--modal-bg);
    padding: var(--spacing-md) var(--spacing-lg) var(--spacing-sm) var(--spacing-lg);
    margin: 0;
    z-index: 10;
  }

  #error-notification > p {
    flex: 1;
    overflow-y: auto;
    padding: 0 var(--spacing-lg) var(--spacing-lg) var(--spacing-lg);
    margin: 0;
  }

  #error-notification .dialog-actions {
    position: sticky;
    bottom: 0;
    background: var(--modal-bg);
    padding: var(--spacing-md) var(--spacing-lg);
    margin: 0;
    border-top: 1px solid var(--border-color);
    z-index: 10;
  }

  /* Mobile: Legend as top bar */
  #legend {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    width: 100%;
    height: auto;
    border-radius: 0;
    padding: var(--spacing-sm);
    z-index: 1100;
  }

  #legend:not(.collapsed) {
    height: 100dvh;
    overflow-y: auto;
    align-items: flex-start;
  }

  #legend.collapsed {
    height: auto;
  }

  .legend-header {
    width: 100%;
    flex-wrap: nowrap;
  }

  .legend-devices-label {
    display: none;
  }

  #legend-search {
    flex: 1;
    min-width: 0;
  }

  /* Move time selector into legend header on mobile */
  .legend-header #time-selector {
    display: flex !important;
    flex-shrink: 0;
    margin-left: var(--spacing-xs);
    position: static;
    background: transparent;
    box-shadow: none;
  }

  .legend-header #time-selector select {
    padding: var(--spacing-xs) var(--spacing-sm);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-sm);
    background: var(--bg-secondary);
    color: var(--text-primary);
    font-size: 0.875rem;
    min-height: 32px;
  }

  .legend-header #time-selector button {
    display: none;
  }

  .legend-items {
    margin-top: var(--spacing-sm);
    align-self: flex-start;
    width: 100%;
  }
}

</style>
</head>
<body>

<section id="map"></section>
<main id="app">
  <!-- Legend -->
  <aside  id="legend" class="collapsed">
    <header class="legend-header">
      <button id="legend-toggle-btn" class="secondary legend-toggle"><i class="fa-regular fa-rectangle-list"></i></button>
      <input type="text" id="legend-search" placeholder="Search Devices">
    </header>
    <div id="legend-items" class="legend-items"></div>
  </aside>

  <!-- Time Selector -->
  <section id="time-selector">
    <select id="time-range">
      <option value="realtime">Real-time</option>
      <option value="today">Today</option>
      <option value="yesterday">Yesterday</option>
      <option value="week">This Week</option>
      <option value="month">This Month</option>
      <option value="custom">Custom Range</option>
    </select>
    <button id="change-time-btn" class="primary" style="display:none;"><i class="fa-solid fa-clock"></i> Change Time</button>
  </section>

  <!-- Custom Time Range -->
  <section id="custom-time">
    <label>From:</label>
    <input type="datetime-local" id="custom-from">
    <label>To:</label>
    <input type="datetime-local" id="custom-to">
    <div class="dialog-actions">
      <div class="dialog-actions-right">
        <button id="cancel-custom" class="secondary">Close</button>
        <button id="custom-apply" class="primary" style="width: 100%;"><i class="fa-solid fa-check"></i> Apply</button>
      </div>  
    </div>
    </section>

  <!-- Settings Modal -->
  <section id="settings-modal">
    <div id="settings-content">
      <h3><i class="fa-solid fa-gear" style="color: var(--accent-fg);"></i>
        Settings</h3>
      <p class="settings-description">Settings are saved automatically</p>
      
      <div class="settings-columns">
        <!-- Left Column: API & Performance -->
        <div>
          <div class="settings-group">
            <label>Traccar API URL:</label>
            <input type="text" id="api-url" value="https://gps.fleetrunnr.com/api">
            <div class="credentials-group">
              <input type="text" id="api-username" placeholder="Username (optional)">
              <input type="password" id="api-password" placeholder="Password (optional)">
            </div>
          </div>

          <div class="settings-row">
            <div class="settings-group">
              <label>Poll Interval (ms):</label>
              <input type="number" id="poll-interval" value="5000" min="1000" step="1000">
            </div>

            <div class="settings-group">
              <label>Movement Threshold (m):</label>
              <input type="number" id="movement-threshold" value="20" min="1" step="1">
            </div>
          </div>

          <div class="settings-group">
            <label>Real-time History (hours):</label>
            <input type="number" id="realtime-hours" value="3" min="1" max="24" step="1">
          </div>
        </div>

        <!-- Right Column: Appearance -->
        <div>
          <div class="settings-group">
            <label>Theme:</label>
            <select id="theme-select">
              <option value="auto">Auto</option>
              <option value="light">Light</option>
              <option value="dark">Dark</option>
            </select>
          </div>

          <div class="settings-row">
            <div class="settings-group">
              <label>Foreground Color:</label>
              <div class="color-picker-wrapper">
                <input type="color" id="foreground-color" value="#4ECDC4">
                <input type="text" id="foreground-color-text" value="#4ECDC4">
              </div>
            </div>

            <div class="settings-group">
              <label>Background Color:</label>
              <div class="color-picker-wrapper">
                <input type="color" id="background-color" value="#2A9D8F">
                <input type="text" id="background-color-text" value="#2A9D8F">
              </div>
            </div>
          </div>

          <div class="settings-group">
            <label>
              <input type="checkbox" id="show-direction-arrows" checked>
              Show direction arrows on trails
            </label>
          </div>

          <div class="settings-group">
            <label for="arrow-spacing">Arrow spacing: <span id="arrow-spacing-value">200</span> pixels</label>
            <input type="range" id="arrow-spacing" min="50" max="500" step="10" value="200" style="width: 100%;">
          </div>

          <div class="settings-group">
            <label>Device Color Palette:</label>
            <div id="palette-manager" class="palette-manager"></div>
            <button id="add-palette-color" class="secondary" style="margin-top: 8px;"><i class="fa-solid fa-palette"></i> Add Color</button>
          </div>
        </div>

        <div class="import-export-group">
          <button id="export-settings" class="secondary"><i class="fa-solid fa-download"></i> Export Settings</button>
          <button id="import-settings" class="secondary"><i class="fa-solid fa-upload"></i> Import Settings</button>
        </div>
      </div>

      <input type="file" id="import-file-input" accept=".json" style="display: none;">

      <div class="dialog-actions">
        <div class="dialog-actions-right">
          <button id="close-settings" class="primary" style="width: 100%; margin-top: 16px;"><i class="fa-solid fa-xmark"></i> Close</button> 
        </div>
      </div>
    </div>
  </section>

  <!-- Color Editor Modal -->
  <section id="color-editor-modal">
    <div id="color-editor-content">
      <h4 style="margin-top: 0;">Edit Color</h4>
      <div class="color-editor-preview" id="color-preview"></div>
      <div class="color-editor-input-group">
        <input type="color" id="color-picker-input" class="color-editor-picker" value="#4ECDC4">
        <input type="text" id="color-hex-input" class="color-editor-input" placeholder="#RRGGBB" maxlength="7">
      </div>
      <div class="dialog-actions">
        <button id="delete-color" class="remove"><i class="fa-solid fa-trash-can"></i> Delete</button>
        <div class="dialog-actions-right">
          <button id="cancel-color" class="secondary">Close</button>
          <button id="save-color" class="primary"><i class="fa-solid fa-floppy-disk"></i> Save</button>
        </div>
      </div>
    </div>
  </section>

  <!-- Timeline Container -->
  <section id="timeline-container">
    <div id="timeline-title">
      <div id="timeline-title-left">
        <button id="timeline-collapse-btn" class="secondary timeline-collapse-btn"><i class="fa-solid fa-caret-up"></i></button>
       
      </div>
      <div id="timeline-title-center">Timeline</div>
      <div id="timeline-title-right">
        <div id="timeline-controls">
          <button id="timeline-action-btn" class="primary" style="display:none;">Clear Selection</button>
          <button id="settings-btn" class="primary"><i class="fa-solid fa-gear"></i></button>
        </div>
      </div>
    </div>
    
    <div id="timeline-wrapper">
      <div id="timeline">
        <div id="timeline-labels-column" class="collapsed"></div>
        <div id="timeline-devices">
          <div id="scrubber" class="timeline-scrubber"></div>
        </div>
      </div>
      <div id="timeline-labels" class="timeline-labels"></div>
    </div>
  </section>
</main>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script src="https://unpkg.com/leaflet-polylinedecorator@1.6.0/dist/leaflet.polylineDecorator.js"></script>
<script>
// ============================================================================
// CONFIGURATION & CONSTANTS
// ============================================================================

const CONFIG = {
  API_URL: 'https://demo4.traccar.org/api/',
  POLL_INTERVAL_MS: 5000,
  MOVEMENT_THRESHOLD_M: 5,
  PALETTE: [
    '#2A9D8F', // Teal
    '#E63946', // Bright Red
    '#F77F00', // Orange
    '#9D4EDD', // Purple
    '#4CC9F0', // Sky Blue
    '#F72585', // Hot Pink
    '#FFD60A', // Yellow
    '#FF006E', // Magenta
    '#118AB2', // Blue
    '#EF476F', // Coral
    '#06FFA5', // Mint Green
    '#06D6A0'  // Sea Green
  ],
  REALTIME_HISTORY_HOURS: 3,
  DRAG_THRESHOLD_PX: 5, // Minimum pixels to move before considering it a drag (vs tap/click)
  SHOW_DIRECTION_ARROWS: true, // Show arrows on polylines to indicate direction of travel
  ARROW_REPEAT_PIXELS: 200, // Pixels between direction arrows on trails
  GEOCODE_CACHE: {},
  // Time constants
  MS_PER_SECOND: 1000,
  MS_PER_MINUTE: 60 * 1000,
  MS_PER_HOUR: 60 * 60 * 1000,
  MS_PER_DAY: 24 * 60 * 60 * 1000,
  SECONDS_PER_MINUTE: 60,
  SECONDS_PER_HOUR: 3600,
  SECONDS_PER_DAY: 86400,
  MINUTES_PER_HOUR: 60,
  MINUTES_PER_DAY: 1440
};

// ============================================================================
// STATE MANAGEMENT
// ============================================================================

const STATE = {
  // Mode and time range
  mode: 'realtime',
  startTime: null,
  endTime: null,
  isLiveMode: true,
  
  // Previous time range (for reverting from zoom/custom)
  previousTimeRange: null,
  
  // Timeline interaction
  selectedTime: null,
  selectionStart: null,
  selectionEnd: null,
  isDragging: false,
  dragStartX: null,
  dragStartY: null,
  timelineLocked: false,
  lockedTime: null,
  
  // Zoom state
  zoomLevel: 1,
  zoomStartTime: null,
  zoomEndTime: null,
  
  // UI state
  isTimelineCollapsed: true,
  isLegendCollapsed: true,
  initialZoomDone: false,
  soloDeviceId: null, 
  editingColorIndex: null,
  
  // Intervals
  liveInterval: null,
  legendUpdateInterval: null,

  // Gap detection
  lastFetchTime: null
};

// Data stores
const DATA = {
  devices: {},
  deviceColors: {},
  deviceNames: {},
  history: {},
  markers: {},
  polylines: {},
  tempMarkers: {},
  movementSegments: {},
  deviceVisibility: {},
  trailDecorators: {}  // One arrow decorator per device trail
};

// Map instance
let map;

// ============================================================================
// THEME MANAGEMENT
// ============================================================================

function applyTheme(theme) {
  if (theme === 'auto') {
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    theme = prefersDark ? 'dark' : 'light';
  }
  
  if (theme === 'dark') {
    document.body.classList.add('dark-mode');
  } else {
    document.body.classList.remove('dark-mode');
  }
  
  const themeSelect = document.getElementById('theme-select');
  if (themeSelect) {
    localStorage.setItem('theme', themeSelect.value || 'auto');
  }
}

function loadTheme() {
  const savedTheme = localStorage.getItem('theme') || 'auto';
  const themeSelect = document.getElementById('theme-select');
  if (themeSelect) {
    themeSelect.value = savedTheme;
  }
  applyTheme(savedTheme);
}

// Watch for system theme changes
window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
  const currentTheme = localStorage.getItem('theme') || 'auto';
  if (currentTheme === 'auto') {
    applyTheme('auto');
  }
});

// ============================================================================
// SETTINGS MANAGEMENT
// ============================================================================

function loadSettings() {
  const savedSettings = localStorage.getItem('traccarSettings');
  if (savedSettings) {
    try {
      const settings = JSON.parse(savedSettings);
      
      // Apply API settings
      if (settings.apiUrl) CONFIG.API_URL = settings.apiUrl;
      if (settings.apiUsername) CONFIG.API_USERNAME = settings.apiUsername;
      if (settings.apiPassword) CONFIG.API_PASSWORD = settings.apiPassword;
      if (settings.pollInterval) CONFIG.POLL_INTERVAL_MS = settings.pollInterval;
      if (settings.movementThreshold) CONFIG.MOVEMENT_THRESHOLD_M = settings.movementThreshold;
      if (settings.realtimeHours) CONFIG.REALTIME_HISTORY_HOURS = settings.realtimeHours;
      if (settings.showDirectionArrows !== undefined) CONFIG.SHOW_DIRECTION_ARROWS = settings.showDirectionArrows;
      if (settings.arrowSpacing) CONFIG.ARROW_REPEAT_PIXELS = settings.arrowSpacing;
      if (settings.palette && Array.isArray(settings.palette)) CONFIG.PALETTE = settings.palette;
      if (settings.foregroundColor) CONFIG.FOREGROUND_COLOR = settings.foregroundColor;
      if (settings.backgroundColor) CONFIG.BACKGROUND_COLOR = settings.backgroundColor;
      
      // Update UI with saved values
      updateSettingsUI();
      applyAccentColors();
    } catch (err) {
      console.error('Failed to load settings:', err);
    }
  } else {
    // Set default accent colors
    CONFIG.FOREGROUND_COLOR = '#4ECDC4';
    CONFIG.BACKGROUND_COLOR = '#2A9D8F';
  }
}

function saveSettings() {
  const settings = {
    apiUrl: CONFIG.API_URL,
    apiUsername: CONFIG.API_USERNAME || '',
    apiPassword: CONFIG.API_PASSWORD || '',
    pollInterval: CONFIG.POLL_INTERVAL_MS,
    movementThreshold: CONFIG.MOVEMENT_THRESHOLD_M,
    realtimeHours: CONFIG.REALTIME_HISTORY_HOURS,
    showDirectionArrows: CONFIG.SHOW_DIRECTION_ARROWS,
    arrowSpacing: CONFIG.ARROW_REPEAT_PIXELS,
    palette: CONFIG.PALETTE,
    foregroundColor: CONFIG.FOREGROUND_COLOR,
    backgroundColor: CONFIG.BACKGROUND_COLOR
  };

  localStorage.setItem('traccarSettings', JSON.stringify(settings));
  applyAccentColors();
}

function updateSettingsUI() {
  const apiUrlInput = document.getElementById('api-url');
  const apiUsernameInput = document.getElementById('api-username');
  const apiPasswordInput = document.getElementById('api-password');
  const pollIntervalInput = document.getElementById('poll-interval');
  const movementThresholdInput = document.getElementById('movement-threshold');
  const realtimeHoursInput = document.getElementById('realtime-hours');
  const showDirectionArrowsInput = document.getElementById('show-direction-arrows');
  const arrowSpacingInput = document.getElementById('arrow-spacing');
  const arrowSpacingValue = document.getElementById('arrow-spacing-value');
  const foregroundColorInput = document.getElementById('foreground-color');
  const foregroundColorTextInput = document.getElementById('foreground-color-text');
  const backgroundColorInput = document.getElementById('background-color');
  const backgroundColorTextInput = document.getElementById('background-color-text');

  if (apiUrlInput) apiUrlInput.value = CONFIG.API_URL;
  if (apiUsernameInput) apiUsernameInput.value = CONFIG.API_USERNAME || '';
  if (apiPasswordInput) apiPasswordInput.value = CONFIG.API_PASSWORD || '';
  if (pollIntervalInput) pollIntervalInput.value = CONFIG.POLL_INTERVAL_MS;
  if (movementThresholdInput) movementThresholdInput.value = CONFIG.MOVEMENT_THRESHOLD_M;
  if (realtimeHoursInput) realtimeHoursInput.value = CONFIG.REALTIME_HISTORY_HOURS;
  if (showDirectionArrowsInput) showDirectionArrowsInput.checked = CONFIG.SHOW_DIRECTION_ARROWS;
  if (arrowSpacingInput) arrowSpacingInput.value = CONFIG.ARROW_REPEAT_PIXELS;
  if (arrowSpacingValue) arrowSpacingValue.textContent = CONFIG.ARROW_REPEAT_PIXELS;
  if (foregroundColorInput) foregroundColorInput.value = CONFIG.FOREGROUND_COLOR || '#4ECDC4';
  if (foregroundColorTextInput) foregroundColorTextInput.value = CONFIG.FOREGROUND_COLOR || '#4ECDC4';
  if (backgroundColorInput) backgroundColorInput.value = CONFIG.BACKGROUND_COLOR || '#2A9D8F';
  if (backgroundColorTextInput) backgroundColorTextInput.value = CONFIG.BACKGROUND_COLOR || '#2A9D8F';

  renderPaletteManager();
}

function renderPaletteManager() {
  const container = document.getElementById('palette-manager');
  if (!container) return;
  
  container.innerHTML = '';
  CONFIG.PALETTE.forEach((color, index) => {
    const swatch = document.createElement('div');
    swatch.className = 'palette-color-swatch';
    swatch.style.backgroundColor = color;
    swatch.title = color;
    swatch.dataset.index = index;
    
    swatch.addEventListener('click', () => {
      openColorEditor(index, color);
    });
    
    container.appendChild(swatch);
  });
}

function openColorEditor(index, color) {
  STATE.editingColorIndex = index;
  const modal = document.getElementById('color-editor-modal');
  const preview = document.getElementById('color-preview');
  const hexInput = document.getElementById('color-hex-input');
  const pickerInput = document.getElementById('color-picker-input');
  
  if (!modal || !preview || !hexInput || !pickerInput) return;
  
  preview.style.backgroundColor = color;
  hexInput.value = color;
  pickerInput.value = color;
  modal.style.display = 'flex';
  hexInput.focus();
  hexInput.select();
}

function closeColorEditor() {
  const modal = document.getElementById('color-editor-modal');
  if (modal) modal.style.display = 'none';
  STATE.editingColorIndex = null;
}

function updateMapColors() {
  // Update all markers on the map with new colors
  Object.keys(DATA.markers).forEach(deviceId => {
    const marker = DATA.markers[deviceId];
    const color = DATA.deviceColors[deviceId];
    if (marker && color) {
      marker.setStyle({
        color: color,
        fillColor: color
      });
    }
  });

  // Update all temp markers on the map with new colors
  Object.keys(DATA.tempMarkers).forEach(deviceId => {
    const marker = DATA.tempMarkers[deviceId];
    const color = DATA.deviceColors[deviceId];
    if (marker && color) {
      marker.setStyle({
        color: color,
        fillColor: color
      });
    }
  });

  // Update all polylines on the map with new colors
  Object.keys(DATA.polylines).forEach(deviceId => {
    const segments = DATA.polylines[deviceId];
    const color = DATA.deviceColors[deviceId];
    if (segments && color) {
      segments.forEach(segment => {
        if (segment) {
          segment.setStyle({
            color: color
          });
        }
      });
    }
  });
}

function saveColorEdit() {
  const input = document.getElementById('color-hex-input');
  if (!input || STATE.editingColorIndex === null) return;
  
  const hexValue = input.value.trim();
  
  // Validate hex color
  if (!/^#[0-9A-F]{6}$/i.test(hexValue)) {
    alert('Please enter a valid hex color (e.g., #FF5733)');
    return;
  }
  
  const oldColor = CONFIG.PALETTE[STATE.editingColorIndex];
  CONFIG.PALETTE[STATE.editingColorIndex] = hexValue.toUpperCase();
  saveSettings();
  renderPaletteManager();

  // Update devices that were using the old color to use the new color
  Object.keys(DATA.deviceColors).forEach((deviceId) => {
    if (DATA.deviceColors[deviceId] === oldColor) {
      DATA.deviceColors[deviceId] = hexValue.toUpperCase();
    }
  });
  updateMapColors();
  drawTimeline();
  updateLegend();

  closeColorEditor();
}

function deleteColorEdit() {
  if (STATE.editingColorIndex === null) return;
  
  if (CONFIG.PALETTE.length <= 1) {
    alert('You must have at least one color in the palette');
    return;
  }
  
  const deletedColor = CONFIG.PALETTE[STATE.editingColorIndex];
  CONFIG.PALETTE.splice(STATE.editingColorIndex, 1);
  saveSettings();
  renderPaletteManager();

  // Reassign devices using the deleted color to the first palette color
  Object.keys(DATA.deviceColors).forEach((deviceId) => {
    if (DATA.deviceColors[deviceId] === deletedColor) {
      DATA.deviceColors[deviceId] = CONFIG.PALETTE[0];
    }
  });
  updateMapColors();
  drawTimeline();
  updateLegend();

  closeColorEditor();
}

function applyAccentColors() {
  const fg = CONFIG.FOREGROUND_COLOR || '#4ECDC4';
  const bg = CONFIG.BACKGROUND_COLOR || '#2A9D8F';
  
  // Set CSS custom properties on document root
  const root = document.documentElement;
  
  root.style.setProperty('--accent-fg', fg);
  root.style.setProperty('--accent-bg', bg);
  
  // Set rgba variants for different opacities
  root.style.setProperty('--accent-fg-10', hexToRgba(fg, 0.1));
  root.style.setProperty('--accent-fg-20', hexToRgba(fg, 0.2));
  root.style.setProperty('--accent-fg-30', hexToRgba(fg, 0.3));
  
  root.style.setProperty('--accent-bg-10', hexToRgba(bg, 0.1));
  root.style.setProperty('--accent-bg-20', hexToRgba(bg, 0.2));
  root.style.setProperty('--accent-bg-30', hexToRgba(bg, 0.3));
}

function hexToRgba(hex, alpha) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function exportSettings() {
  const settings = {
    apiUrl: CONFIG.API_URL,
    apiUsername: CONFIG.API_USERNAME || '',
    apiPassword: CONFIG.API_PASSWORD || '',
    pollInterval: CONFIG.POLL_INTERVAL_MS,
    movementThreshold: CONFIG.MOVEMENT_THRESHOLD_M,
    realtimeHours: CONFIG.REALTIME_HISTORY_HOURS,
    palette: CONFIG.PALETTE,
    foregroundColor: CONFIG.FOREGROUND_COLOR,
    backgroundColor: CONFIG.BACKGROUND_COLOR,
    theme: localStorage.getItem('theme') || 'auto'
  };
  
  const dataStr = JSON.stringify(settings, null, 2);
  const dataBlob = new Blob([dataStr], { type: 'application/json' });
  const url = URL.createObjectURL(dataBlob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'traccar-settings.json';
  link.click();
  URL.revokeObjectURL(url);
}

function importSettings(file) {
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const settings = JSON.parse(e.target.result);
      
      // Validate and apply settings
      if (settings.apiUrl) CONFIG.API_URL = settings.apiUrl;
      if (settings.apiUsername) CONFIG.API_USERNAME = settings.apiUsername;
      if (settings.apiPassword) CONFIG.API_PASSWORD = settings.apiPassword;
      if (settings.pollInterval) CONFIG.POLL_INTERVAL_MS = settings.pollInterval;
      if (settings.movementThreshold) CONFIG.MOVEMENT_THRESHOLD_M = settings.movementThreshold;
      if (settings.realtimeHours) CONFIG.REALTIME_HISTORY_HOURS = settings.realtimeHours;
      if (settings.showDirectionArrows !== undefined) CONFIG.SHOW_DIRECTION_ARROWS = settings.showDirectionArrows;
      if (settings.arrowSpacing) CONFIG.ARROW_REPEAT_PIXELS = settings.arrowSpacing;
      if (settings.palette && Array.isArray(settings.palette)) CONFIG.PALETTE = settings.palette;
      if (settings.foregroundColor) CONFIG.FOREGROUND_COLOR = settings.foregroundColor;
      if (settings.backgroundColor) CONFIG.BACKGROUND_COLOR = settings.backgroundColor;
      if (settings.theme) {
        localStorage.setItem('theme', settings.theme);
        applyTheme(settings.theme);
      }
      
      saveSettings();
      updateSettingsUI();
      
      alert('Settings imported successfully! Please refresh the page for all changes to take effect.');
    } catch (err) {
      console.error('Failed to import settings:', err);
      alert('Failed to import settings. Please check the file format.');
    }
  };
  reader.readAsText(file);
}

// ============================================================================
// MAP INITIALIZATION
// ============================================================================

function initMap() {
  try {
    if (!document.getElementById('map')) {
      throw new Error('Map container not found');
    }

    map = L.map('map').setView([0, 0], 2);
    map.zoomControl.setPosition('bottomright');

    // Create custom panes for proper layer ordering
    // Base layer pane (below overlays)
    map.createPane('basePane');
    const basePane = map.getPane('basePane');
    basePane.style.zIndex = 200;
    basePane.classList.add('leaflet-base-pane');

    // Overlay pane (above base layers)
    map.createPane('overlayPane');
    const overlayPane = map.getPane('overlayPane');
    overlayPane.style.zIndex = 400;
    overlayPane.classList.add('leaflet-overlay-pane');

    // Define multiple tile layers - all use basePane
    const layers = {
      street: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap',
        pane: 'basePane'
      }),
      satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 19,
        attribution: '&copy; Esri',
        pane: 'basePane'
      }),
      topo: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
        maxZoom: 17,
        attribution: '&copy; OpenTopoMap',
        pane: 'basePane'
      }),
      ignPlan: L.tileLayer('https://data.geopf.fr/wmts?REQUEST=GetTile&SERVICE=WMTS&VERSION=1.0.0&STYLE=normal&TILEMATRIXSET=PM&FORMAT=image/png&LAYER=GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}', {
        maxZoom: 19,
        attribution: '&copy; IGN France',
        pane: 'basePane'
      }),
      ignOrtho: L.tileLayer('https://data.geopf.fr/wmts?REQUEST=GetTile&SERVICE=WMTS&VERSION=1.0.0&STYLE=normal&TILEMATRIXSET=PM&FORMAT=image/jpeg&LAYER=HR.ORTHOIMAGERY.ORTHOPHOTOS&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}', {
        maxZoom: 19,
        attribution: '&copy; IGN France',
        pane: 'basePane'
      }),
      cyclOSM: L.tileLayer('https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png', {
        maxZoom: 20,
        attribution: '&copy; OpenStreetMap, CyclOSM',
        pane: 'basePane'
      }),
      transport: L.tileLayer('https://tile.memomaps.de/tilegen/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '&copy; OpenStreetMap, MeMoMaps',
        pane: 'basePane'
      })
    };

    // Define overlays (separate from base layers) - use overlayPane
    const overlays = {
      pistes: L.tileLayer('https://tiles.opensnowmap.org/pistes/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '&copy; OpenStreetMap, OpenSnowMap',
        pane: 'overlayPane'
      })
    };

    // Add default layer (street map)
    let currentLayer = 'street';
    let winterFilterEnabled = false;
    let pistesEnabled = false;
    layers.street.addTo(map);

    // Get tile pane for filter application
    const getTilePane = () => map.getPane('tilePane');

    // Create custom layer switcher control
    const CustomLayerControl = L.Control.extend({
      onAdd: function() {
        const container = L.DomUtil.create('div', 'leaflet-bar custom-layer-control');

        // Toggle button
        const toggleBtn = L.DomUtil.create('a', 'layer-toggle-btn', container);
        toggleBtn.href = '#';
        toggleBtn.innerHTML = '<i class="fa-solid fa-layer-group"></i>';
        toggleBtn.title = 'Map Layers';

        // Menu
        const menu = L.DomUtil.create('div', 'layer-menu', container);

        // Base layers section
        const baseLayers = [
          { key: 'street', label: 'Street', icon: 'fa-map' },
          { key: 'satellite', label: 'Satellite', icon: 'fa-satellite' },
          { key: 'topo', label: 'Topographic', icon: 'fa-mountain' },
          { key: 'ignPlan', label: 'IGN Plan', icon: 'fa-map-location-dot' },
          { key: 'ignOrtho', label: 'IGN Ortho', icon: 'fa-image' },
          { key: 'cyclOSM', label: 'Cycling', icon: 'fa-bicycle' },
          { key: 'transport', label: 'Transport', icon: 'fa-bus' }
        ];

        // Create base layers section label
        const baseLabel = L.DomUtil.create('div', 'layer-menu-section-label', menu);
        baseLabel.textContent = 'Base Maps';

        baseLayers.forEach(option => {
          const item = L.DomUtil.create('div', 'layer-menu-item', menu);
          item.innerHTML = `<i class="fa-solid ${option.icon}"></i> ${option.label}`;
          item.dataset.layer = option.key;

          if (option.key === currentLayer) {
            item.classList.add('active');
          }

          L.DomEvent.on(item, 'click', function(e) {
            L.DomEvent.stopPropagation(e);

            // Remove current layer
            map.removeLayer(layers[currentLayer]);

            // Add new layer
            currentLayer = option.key;
            layers[currentLayer].addTo(map);

            // Update active state for base layers only
            menu.querySelectorAll('.layer-menu-item').forEach(i => {
              if (i.dataset.layer && layers[i.dataset.layer]) {
                i.classList.remove('active');
              }
            });
            item.classList.add('active');

            // Close menu
            menu.classList.remove('show');
          });
        });

        // Add separator
        const separator = L.DomUtil.create('div', 'layer-menu-separator', menu);

        // Overlays section
        const overlayLabel = L.DomUtil.create('div', 'layer-menu-section-label', menu);
        overlayLabel.textContent = 'Overlays';

        // Pistes overlay
        const pistesItem = L.DomUtil.create('div', 'layer-menu-item', menu);
        pistesItem.innerHTML = '<i class="fa-solid fa-person-skiing"></i> Ski Pistes';
        pistesItem.dataset.overlay = 'pistes';

        L.DomEvent.on(pistesItem, 'click', function(e) {
          L.DomEvent.stopPropagation(e);
          pistesEnabled = !pistesEnabled;
          if (pistesEnabled) {
            overlays.pistes.addTo(map);
            pistesItem.classList.add('active');
          } else {
            map.removeLayer(overlays.pistes);
            pistesItem.classList.remove('active');
          }
        });

        // Winter filter overlay
        const winterFilterItem = L.DomUtil.create('div', 'layer-menu-item', menu);
        winterFilterItem.innerHTML = '<i class="fa-solid fa-snowflake"></i> Winter Filter';
        winterFilterItem.dataset.overlay = 'winterFilter';

        L.DomEvent.on(winterFilterItem, 'click', function(e) {
          L.DomEvent.stopPropagation(e);
          winterFilterEnabled = !winterFilterEnabled;
          if (winterFilterEnabled) {
            basePane.classList.add('winter-filter');
            winterFilterItem.classList.add('active');
          } else {
            basePane.classList.remove('winter-filter');
            winterFilterItem.classList.remove('active');
          }
        });

        // Toggle menu visibility
        L.DomEvent.on(toggleBtn, 'click', function(e) {
          L.DomEvent.stopPropagation(e);
          L.DomEvent.preventDefault(e);
          menu.classList.toggle('show');
        });

        // Close menu when clicking outside
        L.DomEvent.on(document, 'click', function() {
          menu.classList.remove('show');
        });

        // Prevent map clicks from propagating
        L.DomEvent.disableClickPropagation(container);

        return container;
      }
    });

    new CustomLayerControl({ position: 'bottomright' }).addTo(map);
  } catch (err) {
    console.error('Map initialization error:', err);
    showError('Failed to initialize map. Please refresh the page.');
    throw err;
  }
}

function clearMap() {
  Object.values(DATA.markers).forEach(safeRemove);
  Object.values(DATA.tempMarkers).forEach(safeRemove);
  Object.values(DATA.polylines).forEach(segments => {
    if (segments) segments.forEach(removePolylineFromMap);
  });
  // Remove all trail decorators
  Object.keys(DATA.trailDecorators).forEach(removeTrailDecorator);

  DATA.markers = {};
  DATA.tempMarkers = {};
  DATA.polylines = {};
  DATA.history = {};
  DATA.movementSegments = {};
  DATA.trailDecorators = {};
}

// ============================================================================
// ERROR DISPLAY
// ============================================================================

function showError(message, canRetry = false) {
  // Create modal wrapper (like settings-modal)
  const errorModal = document.createElement('div');
  errorModal.id = 'error-modal';
  errorModal.style.display = 'flex';

  // Create content container (like settings-content)
  const errorDiv = document.createElement('div');
  errorDiv.id = 'error-notification';

  const errorTitle = document.createElement('h3');
  errorTitle.innerHTML = '<i class="fa-solid fa-triangle-exclamation error-icon " style="color: var(--accent-fg);"></i> We\'ve Got Issues';

  errorDiv.appendChild(errorTitle);

  const messageP = document.createElement('p');
  messageP.innerHTML = message;
  messageP.style.marginBottom = canRetry ? '16px' : '0';
  errorDiv.appendChild(messageP);

  if (canRetry) {

    const dialogActions = document.createElement('div');
    dialogActions.className = 'dialog-actions';
    const dialogActionsRight = document.createElement('div');
    dialogActionsRight.className = 'dialog-actions-right';


    const retryBtn = document.createElement('button');
    retryBtn.id = 'retry-btn';
    retryBtn.innerHTML = '<i class="fa-solid fa-rotate"></i> Retry';
    retryBtn.classList.add('primary');
    dialogActionsRight.appendChild(retryBtn);

    const settingsBtn = document.createElement('button');

    const settingsModal = document.getElementById('settings-modal');
    if (settingsModal) {
      settingsBtn.onclick = () => {
        settingsModal.style.display = 'flex';
        document.body.classList.add('modal-open');
      };
    }

    settingsBtn.id = 'settingsBtn';
    settingsBtn.innerHTML = '<i class="fa-solid fa-gear"></i> Settings';
    settingsBtn.classList.add('primary');
    dialogActionsRight.appendChild(settingsBtn);

    dialogActions.appendChild(dialogActionsRight);

    errorDiv.appendChild(dialogActions);
  }

  errorModal.appendChild(errorDiv);
  document.body.appendChild(errorModal);
  return errorDiv;
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371e3;
  const 1 = lat1 * Math.PI / 180;
  const 2 = lat2 * Math.PI / 180;
  const  = (lat2 - lat1) * Math.PI / 180;
  const  = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin( / 2) * Math.sin( / 2) +
            Math.cos(1) * Math.cos(2) *
            Math.sin( / 2) * Math.sin( / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

function formatDateTimeLocal(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  return `${year}-${month}-${day}T${hours}:${minutes}`;
}

function getTimeAgo(date) {
  const seconds = Math.floor((new Date() - date) / CONFIG.MS_PER_SECOND);
  
  if (seconds < CONFIG.SECONDS_PER_MINUTE) return 'just now';
  if (seconds < 2 * CONFIG.SECONDS_PER_MINUTE) return '1 minute ago';
  if (seconds < CONFIG.SECONDS_PER_HOUR) return Math.floor(seconds / CONFIG.SECONDS_PER_MINUTE) + ' minutes ago';
  if (seconds < 2 * CONFIG.SECONDS_PER_HOUR) return '1 hour ago';
  if (seconds < CONFIG.SECONDS_PER_DAY) return Math.floor(seconds / CONFIG.SECONDS_PER_HOUR) + ' hours ago';
  if (seconds < 2 * CONFIG.SECONDS_PER_DAY) return '1 day ago';
  return Math.floor(seconds / CONFIG.SECONDS_PER_DAY) + ' days ago';
}

function getStatusColor(lastUpdate) {
  const minutesAgo = (new Date() - new Date(lastUpdate)) / CONFIG.MS_PER_MINUTE;
  
  if (minutesAgo < 2) return '#4CAF50'; // Green - online
  if (minutesAgo < 15) return '#9E9E9E'; // Grey - recently online
  return '#F44336'; // Red - offline
}

function getCardinalDirection(degrees) {
  if (degrees == null) return null;
  
  const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
  const index = Math.round(((degrees % 360) / 45)) % 8;
  return directions[index];
}

function getDirectionArrow(degrees) {
  if (degrees == null) return '';
  
  const arrows = ['', '', '', '', '', '', '', ''];
  const index = Math.round(((degrees % 360) / 45)) % 8;
  return arrows[index];
}

function formatSpeed(speedKnots) {
  if (speedKnots == null) return null;
  const kmh = speedKnots * 1.852;
  return kmh.toFixed(1) + ' km/h';
}

function formatDistance(meters) {
  if (meters == null) return null;
  if (meters < 1000) return meters.toFixed(0) + ' m';
  return (meters / 1000).toFixed(2) + ' km';
}

function safeRemove(layer) {
  if (layer && map && map.hasLayer(layer)) {
    map.removeLayer(layer);
  }
}

function formatAddress(addressData) {
  if (!addressData || !addressData.address) return null;
  
  const addr = addressData.address;
  const parts = [];
  
  // Address line 1 (street number + street name)
  const street = [addr.house_number, addr.road].filter(Boolean).join(' ');
  if (street) parts.push(street);
  
  // Town/City
  const city = addr.city || addr.town || addr.village || addr.municipality;
  if (city) parts.push(city);
  
  // County
  if (addr.county) parts.push(addr.county);
  
  // Postcode
  if (addr.postcode) parts.push(addr.postcode);
  
  // Country
  if (addr.country) parts.push(addr.country);
  
  return parts.length > 0 ? parts.join(', ') : null;
}

async function reverseGeocode(lat, lon) {
  const key = `${lat.toFixed(4)},${lon.toFixed(4)}`;
  
  if (CONFIG.GEOCODE_CACHE[key]) {
    return CONFIG.GEOCODE_CACHE[key];
  }
  
  try {
    const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=18&addressdetails=1`;
    const res = await fetch(url, {
      headers: {
        'User-Agent': 'TraccarMapTimeline/1.0'
      }
    });
    
    if (!res.ok) {
      console.warn('Geocoding failed:', res.status);
      return null;
    }
    
    const data = await res.json();
    const address = formatAddress(data) || data.display_name || 'Unknown location';
    CONFIG.GEOCODE_CACHE[key] = address;
    return address;
  } catch (err) {
    console.error('Geocoding error:', err);
    return null;
  }
}

// ============================================================================
// MAP POPUP
// ============================================================================


function bindPopupWithGeocode(marker, deviceId, positionData) {
  const popupContent = createPopupContent(deviceId, positionData);
  const popup = marker.bindPopup(popupContent);
  
  popup.on('popupopen', () => {
    const latlng = marker.getLatLng();
    reverseGeocode(latlng.lat, latlng.lng).then(address => {
      const addressDiv = document.getElementById(`address-${deviceId}`);
      if (addressDiv) {
        addressDiv.innerHTML = '';
        if (address) {
          addressDiv.innerHTML = '<i class="fa-solid fa-map-location-dot"></i> ' + address;
        } else {
          const em = document.createElement('em');
          em.textContent = 'Address unavailable';
          addressDiv.appendChild(document.createTextNode('<i class="fa-solid fa-map-location-dot"></i> '));
          addressDiv.appendChild(em);
        }
      }
    });
  });
  
  return popup;
}

function bindDeviceNameTooltip(marker, deviceId) {
  const deviceName = DATA.deviceNames[deviceId];
  if (deviceName) {
    marker.bindTooltip(deviceName, {
      permanent: true,
      direction: 'top',
      offset: [0, -10],
      className: 'device-name-tooltip'
    });
  }
}

function centerMapWithPopup(latLng, zoomLevel = 15) {
  // Get timeline height
  const timelineContainer = document.getElementById('timeline-container');
  const timelineHeight = timelineContainer ? timelineContainer.offsetHeight : 0;
  
  // Get map container height
  const mapContainer = document.getElementById('map');
  const mapHeight = mapContainer ? mapContainer.offsetHeight : window.innerHeight;
  
  // Calculate the visible map height (excluding timeline)
  const visibleMapHeight = mapHeight - timelineHeight;
  
  // We want the marker centered horizontally and positioned so popup appears above timeline
  // Popup is typically ~200px tall, we want some padding above timeline
  const popupHeightEstimate = 200;
  const paddingAboveTimeline = 20;
  
  // Target position: marker should be at this Y coordinate (from top)
  const targetY = visibleMapHeight - popupHeightEstimate - paddingAboveTimeline;
  
  // Get the point in pixel coordinates at current zoom
  const point = map.project(latLng, zoomLevel);
  
  // Calculate how much we need to offset (positive = move map down, marker appears higher)
  const centerY = mapHeight / 2;
  const offsetY = centerY - targetY;
  
  // Apply offset
  point.y += offsetY;
  
  // Convert back to lat/lng
  const offsetLatLng = map.unproject(point, zoomLevel);
  
  // Set view
  map.setView(offsetLatLng, zoomLevel);
}

function createPopupContent(deviceId, positionData) {
  const {
    timestamp,
    speed,
    course,
    accuracy,
    attributes: attrs = {}
  } = positionData;

  const name  = DATA.deviceNames[deviceId];
  const color = DATA.deviceColors[deviceId];

  const motion =
    attrs.motion != null
      ? `<div class="popup-motion">
           ${attrs.motion ? '' : ''}
           <strong>${attrs.motion ? 'Moving' : 'Stationary'}</strong>
         </div>`
      : '';

  const speedHtml =
    speed > 0
      ? `<div class="popup-speed">
            Speed: <strong>${formatSpeed(speed)}</strong>
         </div>`
      : '';

  const courseHtml =
    course != null
      ? `<div class="popup-section">
           <span class="popup-arrow">${getDirectionArrow(course)}</span>
           Heading:
           <strong>${getCardinalDirection(course)}</strong>
           (${course.toFixed(0)})
         </div>`
      : '';

  const batteryHtml =
    attrs.batteryLevel != null
      ? `<div class="popup-section popup-battery ${attrs.batteryLevel > 20 ? 'ok' : 'low'}">
           ${attrs.batteryLevel > 20 ? '' : ''} Battery:
           <strong>${attrs.batteryLevel}%</strong>
         </div>`
      : '';

  const distanceHtml =
    (attrs.distance != null || attrs.totalDistance != null)
      ? `<div class="popup-section">
           ${attrs.distance != null
             ? `<div> Trip: <strong>${formatDistance(attrs.distance)}</strong></div>`
             : ''}
           ${attrs.totalDistance != null
             ? `<div> Total: <strong>${formatDistance(attrs.totalDistance)}</strong></div>`
             : ''}
         </div>`
      : '';

  const accuracyHtml =
    accuracy != null
      ? `<div class="popup-section">
            Accuracy:
           <strong>${accuracy.toFixed(1)} m</strong>
         </div>`
      : '';

  const container = document.createElement('div');
  container.className = 'map-popup';
  container.style.setProperty('--device-color', color);

  container.innerHTML = `
    <header class="popup-header">
      <strong class="popup-title">${name}</strong>
      <div class="popup-divider"></div>
    </header>

    <section class="popup-time">
      <div> ${timestamp.toLocaleString()}</div>
      <div class="popup-time-ago">(${getTimeAgo(timestamp)})</div>
    </section>

    ${(motion || speedHtml)
      ? `<section class="popup-section">${motion}${speedHtml}</section>`
      : ''}

    ${courseHtml}
    ${batteryHtml}
    ${distanceHtml}
    ${accuracyHtml}

    <section id="address-${deviceId}" class="popup-address">
      <em>Loading address...</em>
    </section>
  `;

  return container;
}

// ============================================================================
// LEGEND MANAGEMENT
// ============================================================================

function updateLegend(highlightedDevices = null) {
  const legendItems = document.getElementById('legend-items');
  if (!legendItems) return;
  
  legendItems.innerHTML = '';
  
  Object.keys(DATA.deviceNames).forEach(id => {
    const item = document.createElement('div');
    item.className = 'legend-item';

    // Check if device has position data in current time range
    const hasDataInRange = DATA.history[id] && DATA.history[id].length > 0;
    const isVisible = DATA.deviceVisibility[id];

    // Add data attributes for filtering
    const device = DATA.devices[id];
    item.dataset.deviceId = id;
    item.dataset.deviceName = DATA.deviceNames[id].toLowerCase();

    // Add status for filtering
    if (device && device.lastUpdate) {
      const lastUpdate = new Date(device.lastUpdate);
      const minutesAgo = Math.floor((new Date() - lastUpdate) / CONFIG.MS_PER_MINUTE);
      if (minutesAgo < 2) {
        item.dataset.status = 'online';
      } else if (minutesAgo < 15) {
        item.dataset.status = 'recent';
      } else {
        item.dataset.status = 'offline';
      }
      item.dataset.lastUpdate = device.lastUpdate;
    } else {
      item.dataset.status = 'unknown';
    }

    // Add aria attributes for accessibility
    item.setAttribute('role', 'button');
    item.setAttribute('aria-label', `${DATA.deviceNames[id]}, ${item.dataset.status}`);
    item.setAttribute('aria-pressed', isVisible ? 'true' : 'false');
    item.setAttribute('tabindex', '0');
    
    // Apply appropriate classes
    if (!isVisible) {
      item.classList.add('disabled');
    }
    
    // In non-realtime modes, also add 'inactive' class if no data (same visual effect)
    if (!hasDataInRange && STATE.mode !== 'realtime') {
      item.classList.add('inactive');
    }
    
    const colorBox = document.createElement('div');
    colorBox.className = 'color-box';
    // Color box will be greyed by CSS if either disabled or inactive class is present
    colorBox.style.background = DATA.deviceColors[id];
    
    const name = document.createElement('span');
    name.className = 'legend-item-name';
    name.textContent = DATA.deviceNames[id];
    
    const status = document.createElement('span');
    status.className = 'legend-item-status';

    if (device) {
      const lastUpdate = device.lastUpdate ? new Date(device.lastUpdate) : null;
      if (lastUpdate) {
        const minutesAgo = Math.floor((new Date() - lastUpdate) / CONFIG.MS_PER_MINUTE);
        const indicator = document.createElement('span');
        indicator.className = 'status-indicator';
        
        // Updated status colors: <2min green, 2-15min grey, >15min red
        if (minutesAgo < 2) {
          indicator.style.background = '#4CAF50';
          indicator.title = 'Online';
        } else if (minutesAgo < 15) {
          indicator.style.background = '#9E9E9E';
          indicator.title = 'Recently Online';
        } else {
          indicator.style.background = '#F44336';
          indicator.title = 'Offline';
        }
        
        status.appendChild(indicator);
        
        if (minutesAgo < 60) {
          status.appendChild(document.createTextNode(`${minutesAgo}m ago`));
        } else if (minutesAgo < 1440) {
          status.appendChild(document.createTextNode(`${Math.floor(minutesAgo / 60)}h ago`));
        } else {
          status.appendChild(document.createTextNode(`${Math.floor(minutesAgo / 1440)}d ago`));
        }
      }
    }
    
    item.appendChild(colorBox);
    item.appendChild(name);
    item.appendChild(status);
    
    // Legend click behavior
    item.onclick = () => {
      // If timeline is locked (time selected), show popup for device at that time
      if (STATE.timelineLocked && STATE.lockedTime && hasDataInRange) {
        const history = DATA.history[id];
        if (history && history.length > 0) {
          // Find closest position to locked time
          let closestPos = history[0];
          let minDiff = Math.abs(history[0].timestamp - STATE.lockedTime);

          for (const pos of history) {
            const diff = Math.abs(pos.timestamp - STATE.lockedTime);
            if (diff < minDiff) {
              minDiff = diff;
              closestPos = pos;
            }
          }

          // Focus on this position and show popup
          centerMapWithPopup(closestPos.coords, 15);

          // Use temp marker if it exists, otherwise create one
          if (DATA.tempMarkers[id]) {
            DATA.tempMarkers[id].openPopup();
          } else {
            const tempMarker = L.circleMarker(closestPos.coords, {
              radius: 6,
              color: DATA.deviceColors[id],
              fillColor: DATA.deviceColors[id],
              fillOpacity: 0.7,
              weight: 2
            }).addTo(map);


            bindPopupWithGeocode(tempMarker, id, closestPos);
            bindDeviceNameTooltip(tempMarker, id);
            tempMarker.openPopup();

            DATA.tempMarkers[id] = tempMarker;

            // Hide main marker
            if (DATA.markers[id] && map.hasLayer(DATA.markers[id])) {
              safeRemove(DATA.markers[id]);
            }
          }
        }
      } else if (DATA.markers[id]) {
        // Normal behavior: focus on most recent marker
        centerMapWithPopup(DATA.markers[id].getLatLng(), 15);
        DATA.markers[id].openPopup();
      }

      // Auto-collapse legend on mobile after selecting a device
      if (window.innerWidth <= 768) {
        const legend = document.getElementById('legend');
        const legendToggleBtn = document.getElementById('legend-toggle-btn');
        if (legend && legendToggleBtn && !STATE.isLegendCollapsed) {
          STATE.isLegendCollapsed = true;
          legendToggleBtn.innerHTML = '<i class="fa-regular fa-rectangle-list"></i>';
          legend.classList.add('collapsed');
        }
      }
    };
    
    legendItems.appendChild(item);
  });
}

function setDeviceVisibility(deviceId, visible) {
  // Only do work if state is changing
  if (DATA.deviceVisibility[deviceId] === visible) return;

  DATA.deviceVisibility[deviceId] = visible;

  const marker = DATA.markers[deviceId];
  const tempMarker = DATA.tempMarkers[deviceId];
  const polylineSegments = DATA.polylines[deviceId];

  if (visible) {
    // Show
    if (marker && !map.hasLayer(marker)) {
      marker.addTo(map);
    }
    if (tempMarker && !map.hasLayer(tempMarker)) {
      tempMarker.addTo(map);
    }
    // Use helper to show polylines and trail decorator
    setPolylineVisibility(polylineSegments, deviceId, true);
  } else {
    // Hide
    if (marker) {
      safeRemove(marker);
    }
    if (tempMarker) {
      safeRemove(tempMarker);
    }
    // Use helper to hide polylines and trail decorator
    setPolylineVisibility(polylineSegments, deviceId, false);
  }

}

function toggleDeviceVisibility(deviceId) {
  setDeviceVisibility(deviceId, !DATA.deviceVisibility[deviceId]);
  updateLegend();
  updateTimelineAppearance();
}

function updateTimelineAppearance() {
  const labels = document.querySelectorAll('.timeline-device-name');
  labels.forEach(label => {
    const deviceId = label.dataset.deviceId;
    if (DATA.deviceVisibility[deviceId]) {
      label.classList.remove('disabled');
    } else {
      label.classList.add('disabled');
    }
  }); 
  const tracksContainers = document.querySelectorAll('.timeline-device-tracks');
  tracksContainers.forEach(tracksContainer => {
    
    const deviceId = tracksContainer.dataset.deviceId;
    if (DATA.deviceVisibility[deviceId]) {
      tracksContainer.classList.remove('disabled');
    } else {
      tracksContainer.classList.add('disabled');
    }
  });
}

// ============================================================================
// POLYLINE ARROW DECORATORS
// ============================================================================

// Create a single trail decorator for an entire device trail
function createTrailDecorator(deviceId, color) {
  if (!CONFIG.SHOW_DIRECTION_ARROWS) return null;
  if (!DATA.history[deviceId] || DATA.history[deviceId].length < 2) return null;

  try {
    // Build coordinates array from history
    const coords = DATA.history[deviceId].map(h => h.coords);

    const decorator = L.polylineDecorator(L.polyline(coords), {
      patterns: [
        {
          offset: 0,
          repeat: CONFIG.ARROW_REPEAT_PIXELS,
          symbol: L.Symbol.arrowHead({
            pixelSize: 10,
            polygon: false,
            pathOptions: {
              stroke: true,
              color: color,
              weight: 2,
              fillOpacity: 1,
              fill: true
            }
          })
        }
      ]
    });

    return decorator;
  } catch (err) {
    console.error('Error creating trail decorator:', err);
    return null;
  }
}

// Remove and recreate the trail decorator for a device
function updateTrailDecorator(deviceId) {
  // Remove existing decorator
  if (DATA.trailDecorators[deviceId]) {
    map.removeLayer(DATA.trailDecorators[deviceId]);
    DATA.trailDecorators[deviceId] = null;
  }

  // Create new decorator if arrows enabled and device visible
  if (CONFIG.SHOW_DIRECTION_ARROWS && DATA.deviceVisibility[deviceId]) {
    const decorator = createTrailDecorator(deviceId, DATA.deviceColors[deviceId]);
    if (decorator) {
      decorator.addTo(map);
      DATA.trailDecorators[deviceId] = decorator;
    }
  }
}

// Remove trail decorator for a device
function removeTrailDecorator(deviceId) {
  if (DATA.trailDecorators[deviceId]) {
    map.removeLayer(DATA.trailDecorators[deviceId]);
    DATA.trailDecorators[deviceId] = null;
  }
}

// Helper function to remove a polyline from the map (no longer handles decorators)
function removePolylineFromMap(segment) {
  if (!segment) return;
  safeRemove(segment);
}

// Helper function to add a polyline to the map (if visible) - no decorator
function addPolylineToMap(segment, deviceId) {
  if (!segment) return;

  if (DATA.deviceVisibility[deviceId] && !map.hasLayer(segment)) {
    segment.addTo(map);
  }
}

// Helper function to show/hide polyline segments (decorators handled separately)
function setPolylineVisibility(segments, deviceId, visible) {
  if (!segments) return;

  segments.forEach(segment => {
    if (!segment) return;

    if (visible) {
      if (!map.hasLayer(segment)) {
        segment.addTo(map);
      }
    } else {
      safeRemove(segment);
    }
  });

  // Handle trail decorator visibility
  if (visible) {
    updateTrailDecorator(deviceId);
  } else {
    removeTrailDecorator(deviceId);
  }
}

// ============================================================================
// MOVEMENT DETECTION
// ============================================================================

function detectMovementSegments(deviceId) {
  const positions = DATA.history[deviceId];
  if (!positions || positions.length < 2) return [];
  
  const segments = [];
  let currentSegment = null;
  
  for (let i = 1; i < positions.length; i++) {
    const prev = positions[i - 1];
    const curr = positions[i];
    
    const distance = calculateDistance(
      prev.coords[0], prev.coords[1],
      curr.coords[0], curr.coords[1]
    );
    
    if (distance > CONFIG.MOVEMENT_THRESHOLD_M) {
      if (!currentSegment) {
        currentSegment = { start: prev.timestamp, end: curr.timestamp };
      } else {
        currentSegment.end = curr.timestamp;
      }
    } else {
      if (currentSegment) {
        segments.push(currentSegment);
        currentSegment = null;
      }
    }
  }
  
  if (currentSegment) {
    segments.push(currentSegment);
  }
  
  return segments;
}

// ============================================================================
// DATA FETCHING
// ============================================================================

function getAuthHeaders() {
  const headers = {
    'Content-Type': 'application/json'
  };
  
  if (CONFIG.API_USERNAME && CONFIG.API_PASSWORD) {
    const credentials = btoa(`${CONFIG.API_USERNAME}:${CONFIG.API_PASSWORD}`);
    headers['Authorization'] = `Basic ${credentials}`;
  }
  
  return headers;
}

async function authenticatedFetch(url, options = {}) {
  const headers = getAuthHeaders();
  return fetch(url, {
    ...options,
    headers: {
      ...headers,
      ...(options.headers || {})
    }
  });
}

async function fetchDevices() {
  try {
    const res = await authenticatedFetch(CONFIG.API_URL + 'devices');
    
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    }
    
    const devices = await res.json();
    
    if (!devices || devices.length === 0) {
      console.warn('No devices found');
      showError('No tracking devices found. Please ensure devices are configured in Traccar.', false);
      return;
    }
    
    devices.forEach((d, idx) => {
      DATA.devices[d.id] = d;
      DATA.deviceNames[d.id] = d.name;
      DATA.deviceColors[d.id] = CONFIG.PALETTE[idx % CONFIG.PALETTE.length];
      DATA.deviceVisibility[d.id] = true;
    });
    
    updateLegend();
  } catch (err) {
    console.error('Error fetching devices:', err);


    throw new Error(`Failed to connect to Traccar API: ${err.message}<br><br>Please check:<ul><li>Traccar server is running</li><li>API URL is correctly set<br /><span class="config-badge"><strong>CONFIG.API_URL:</strong> ${CONFIG.API_URL}</span></li></ul><strong>Note:</strong> If this is your first time running the app, open Settings and set the Traccar API URL, then reload.`);
    /*
    const errorDiv = showError(`Failed to connect to Traccar API: ${err.message}<br><br>Please check:<ul><li>API URL is correct: ${CONFIG.API_URL}</li><li>Traccar server is running</li></ul><strong>Note:</strong>If this is your first time running the app, open Settings and set the Traccar API URL, then reload.`, true);
    
    const retryBtn = document.getElementById('retry-btn');
    if (retryBtn) {
      retryBtn.onclick = () => {
        errorDiv.remove();
        fetchDevices();
      };
    }
    throw err;
    */
  }
}

async function fetchHistoryForRange(fromTime, toTime) {
  try {
    // Clear any existing error notifications
    const errorModal = document.getElementById('error-modal');
    if (errorModal) {
      errorModal.remove();
    }
    
    clearMap();
    
    STATE.startTime = new Date(fromTime);
    STATE.endTime = new Date(toTime);
    
    const allLatLngs = [];
    
    await Promise.all(Object.keys(DATA.deviceNames).map(async (id) => {
      try {
        const url = `${CONFIG.API_URL}positions?deviceId=${id}&from=${fromTime}&to=${toTime}`;
        const res = await authenticatedFetch(url);
        if (!res.ok) {
          console.warn(`Failed to fetch positions for device ${id}: HTTP ${res.status}`);
          return;
        }
        
        const positions = await res.json();
        if (!positions || !positions.length) {
          console.info(`No positions found for device ${DATA.deviceNames[id]} in selected time range`);
          return;
        }
        
        DATA.history[id] = positions.map(p => ({
          coords: [p.latitude, p.longitude],
          timestamp: new Date(p.fixTime || p.deviceTime),
          speed: p.speed,
          course: p.course,
          accuracy: p.accuracy,
          attributes: p.attributes || {}
        }));

        DATA.history[id].sort((a, b) => a.timestamp - b.timestamp);

        DATA.movementSegments[id] = detectMovementSegments(id);

        DATA.history[id].forEach((h, i) => {
          if (i === 0) return;
          const opacity = 0.3 + 0.7 * (i / DATA.history[id].length);
          const segment = L.polyline(
            [DATA.history[id][i - 1].coords, h.coords],
            { color: DATA.deviceColors[id], opacity, weight: 3 }
          );

          // Add hover effect to highlight timeline
          segment.on('mouseover', function() {
            this.setStyle({ weight: 5, opacity: 1 });
            highlightTimelineForTime(id, h.timestamp);
          });

          segment.on('mouseout', function() {
            this.setStyle({ weight: 3, opacity });
            clearTimelineHighlight();
          });

          // Add click handler to select time on timeline
          segment.on('click', function() {
            selectTimeOnTimeline(id, h.timestamp);
          });

          if (!DATA.polylines[id]) DATA.polylines[id] = [];
          DATA.polylines[id].push(segment);

          // Add segment to map (decorator created after all segments)
          addPolylineToMap(segment, id);
        });

        // Create single trail decorator for this device
        updateTrailDecorator(id);

        const last = DATA.history[id][DATA.history[id].length - 1];
        const lastCoords = last.coords;

        const marker = L.circleMarker(lastCoords, {
          radius: 8,
          color: DATA.deviceColors[id],
          fillColor: DATA.deviceColors[id],
          fillOpacity: 0.9,
          weight: 2
        });

        bindPopupWithGeocode(marker, id, last);
        bindDeviceNameTooltip(marker, id);

        DATA.markers[id] = marker;

        // Only add to map if device is visible
        if (DATA.deviceVisibility[id] && !map.hasLayer(marker)) {
          marker.addTo(map);
        }
        
        allLatLngs.push(...DATA.history[id].map(h => h.coords));
      } catch (err) {
        console.error(`Error fetching history for device ${id}:`, err);
      }
    }));

    if (allLatLngs.length && !STATE.initialZoomDone) {
      map.fitBounds(L.latLngBounds(allLatLngs), { padding: [50, 50] });
      STATE.initialZoomDone = true;
    } else if (allLatLngs.length && STATE.mode !== 'realtime') {
      // Only auto-fit bounds for non-realtime modes
      map.fitBounds(L.latLngBounds(allLatLngs), { padding: [50, 50] });
    } else if (allLatLngs.length === 0) {
      console.warn('No position data found for any devices in the selected time range');
      // Don't show error in real-time mode, devices may just not have moved yet
      if (STATE.mode !== 'realtime') {
        showError('No position data found for the selected time range.', false);
      }
    }

    drawTimeline();
    updateTimelineTitle();
    updateTimelineButtons();
  } catch (err) {
    console.error('Error in fetchHistoryForRange:', err);
    showError(`Failed to fetch position history: ${err.message}`, true);
    
    const retryBtn = document.getElementById('retry-btn');
    if (retryBtn) {
      retryBtn.onclick = () => {
        const errorModal = document.getElementById('error-modal');
        if (errorModal) {
          errorModal.remove();
        }
        fetchHistoryForRange(fromTime, toTime);
      };
    }
  }
}

async function fetchMissingPositions(fromTime, toTime) {
  console.log('[Backfill] Detected gap in position updates, fetching missing positions...');

  try {
    let totalBackfilled = 0;

    // Fetch missing positions for each device
    await Promise.all(Object.keys(DATA.deviceNames).map(async (id) => {
      try {
        const url = `${CONFIG.API_URL}positions?deviceId=${id}&from=${fromTime.toISOString()}&to=${toTime.toISOString()}`;
        const res = await authenticatedFetch(url);

        if (!res.ok) {
          console.warn(`[Backfill] Failed to fetch positions for device ${id}: HTTP ${res.status}`);
          return;
        }

        const positions = await res.json();
        if (!positions || !positions.length) {
          return;
        }

        // Convert to our position format
        const newPositions = positions.map(p => ({
          coords: [p.latitude, p.longitude],
          timestamp: new Date(p.fixTime || p.deviceTime),
          speed: p.speed,
          course: p.course,
          accuracy: p.accuracy,
          attributes: p.attributes || {}
        }));

        // Get existing history
        const existingHistory = DATA.history[id] || [];

        // Merge and deduplicate based on timestamp
        const allPositions = [...existingHistory, ...newPositions];

        // Create a map to deduplicate by timestamp (keeping first occurrence)
        const uniqueMap = new Map();
        allPositions.forEach(pos => {
          const timeKey = pos.timestamp.getTime();
          if (!uniqueMap.has(timeKey)) {
            uniqueMap.set(timeKey, pos);
          }
        });

        // Convert back to array and sort by timestamp
        DATA.history[id] = Array.from(uniqueMap.values()).sort((a, b) => a.timestamp - b.timestamp);

        const backfilledCount = newPositions.length;
        totalBackfilled += backfilledCount;

        // Redraw polylines for this device
        if (DATA.polylines[id]) {
          DATA.polylines[id].forEach(removePolylineFromMap);
          DATA.polylines[id] = [];
        }
        // Remove trail decorator (will be recreated after new polylines)
        removeTrailDecorator(id);

        DATA.history[id].forEach((h, i) => {
          if (i === 0) return;
          const opacity = 0.3 + 0.7 * (i / DATA.history[id].length);
          const segment = L.polyline(
            [DATA.history[id][i - 1].coords, h.coords],
            { color: DATA.deviceColors[id], opacity, weight: 3 }
          );

          // Add hover effect to highlight timeline
          segment.on('mouseover', function() {
            this.setStyle({ weight: 5, opacity: 1 });
            highlightTimelineForTime(id, h.timestamp);
          });

          segment.on('mouseout', function() {
            this.setStyle({ weight: 3, opacity });
            clearTimelineHighlight();
          });

          // Add click handler to select time on timeline
          segment.on('click', function() {
            selectTimeOnTimeline(id, h.timestamp);
          });

          if (!DATA.polylines[id]) DATA.polylines[id] = [];
          DATA.polylines[id].push(segment);

          // Add segment to map (decorator created after all segments)
          addPolylineToMap(segment, id);
        });

        // Create single trail decorator for this device
        updateTrailDecorator(id);

        // Update movement segments
        DATA.movementSegments[id] = detectMovementSegments(id);

      } catch (err) {
        console.error(`[Backfill] Error fetching positions for device ${id}:`, err);
      }
    }));

    console.log(`[Backfill] Backfilled ${totalBackfilled} position(s) across all devices`);

    // Redraw timeline to show new positions
    if (STATE.mode === 'realtime') {
      drawTimeline();
    }

  } catch (err) {
    console.error('[Backfill] Error during backfill:', err);
  }
}

async function fetchLive() {
  if (!STATE.isLiveMode) return;

  // Gap detection: Check if we've been away for too long
  const now = new Date();
  const threshold = CONFIG.POLL_INTERVAL_MS * 2.5;

  if (STATE.lastFetchTime) {
    const timeSinceLastFetch = now - STATE.lastFetchTime;

    if (timeSinceLastFetch > threshold) {
      console.log(`[Gap Detection] Time since last fetch: ${Math.round(timeSinceLastFetch / 1000)}s (threshold: ${Math.round(threshold / 1000)}s)`);
      // Backfill missing positions from when we were away
      await fetchMissingPositions(STATE.lastFetchTime, now);
    }
  }

  // Update last fetch time
  STATE.lastFetchTime = now;

  try {
    const res = await authenticatedFetch(CONFIG.API_URL + 'positions');
    if (!res.ok) {
      console.warn(`Live position fetch failed: HTTP ${res.status}`);
      return;
    }

    const positions = await res.json();
    
    for (const device of positions) {
      const id = device.deviceId;
      const latlng = [device.latitude, device.longitude];
      const positionData = {
        coords: latlng,
        timestamp: new Date(device.fixTime || device.deviceTime),
        speed: device.speed,
        course: device.course,
        accuracy: device.accuracy,
        attributes: device.attributes || {}
      };

      // If marker doesn't exist yet (device just came online), create it
      if (!DATA.markers[id]) {
        const marker = L.circleMarker(latlng, {
          radius: 8,
          color: DATA.deviceColors[id],
          fillColor: DATA.deviceColors[id],
          fillOpacity: 0.9,
          weight: 2
        });

        bindPopupWithGeocode(marker, id, positionData);
        bindDeviceNameTooltip(marker, id);
        DATA.markers[id] = marker;

        // Only add to map if device is visible
        if (DATA.deviceVisibility[id] && !map.hasLayer(marker)) {
          marker.addTo(map);
        }
        
        // Initialize history for this device
        if (!DATA.history[id]) DATA.history[id] = [];
        DATA.history[id].push(positionData);
      }

      if (DATA.markers[id] && !DATA.tempMarkers[id]) {
        DATA.markers[id].setLatLng(latlng);
        
        const popupContent = createPopupContent(id, positionData);
        DATA.markers[id].setPopupContent(popupContent);
        
        if (!DATA.history[id]) DATA.history[id] = [];
        DATA.history[id].push(positionData);
        
        if (DATA.history[id].length > 1) {
          const prev = DATA.history[id][DATA.history[id].length - 2];
          const opacity = 0.8;
          const segment = L.polyline(
            [prev.coords, latlng],
            { color: DATA.deviceColors[id], opacity, weight: 3 }
          );

          // Add hover effect to highlight timeline
          segment.on('mouseover', function() {
            this.setStyle({ weight: 5, opacity: 1 });
            highlightTimelineForTime(id, positionData.timestamp);
          });

          segment.on('mouseout', function() {
            this.setStyle({ weight: 3, opacity: 0.8 });
            clearTimelineHighlight();
          });

          // Add click handler to select time on timeline
          segment.on('click', function() {
            selectTimeOnTimeline(id, positionData.timestamp);
          });

          if (!DATA.polylines[id]) DATA.polylines[id] = [];
          DATA.polylines[id].push(segment);

          // Add segment to map and update trail decorator
          addPolylineToMap(segment, id);
          updateTrailDecorator(id);

          const distance = calculateDistance(
            prev.coords[0], prev.coords[1],
            latlng[0], latlng[1]
          );
          
          if (distance > CONFIG.MOVEMENT_THRESHOLD_M) {
            if (!DATA.movementSegments[id]) DATA.movementSegments[id] = [];
            const lastSeg = DATA.movementSegments[id][DATA.movementSegments[id].length - 1];
            
            if (lastSeg && (positionData.timestamp - lastSeg.end) < CONFIG.MS_PER_MINUTE) {
              lastSeg.end = positionData.timestamp;
            } else {
              DATA.movementSegments[id].push({
                start: prev.timestamp,
                end: positionData.timestamp
              });
            }
          }
        }
      }
    }
    
    try {
      const devicesRes = await authenticatedFetch(CONFIG.API_URL + 'devices');
      if (devicesRes.ok) {
        const devices = await devicesRes.json();
        devices.forEach(d => {
          DATA.devices[d.id] = d;
        });
      }
    } catch (err) {
      console.warn('Failed to update device status:', err);
    }
    
    if (STATE.mode === 'realtime') {
      STATE.endTime = new Date();
      drawTimeline();
    }
    
    updateLegend();
  } catch (err) {
    console.error('Error fetching live positions:', err);
  }
}

// ============================================================================
// TIMELINE
// ============================================================================

function setupTimelineInteraction(timelineDevices, durationMs) {
  // Hover and click interaction on timeline-devices container
  // Mouse events
  timelineDevices.onmousedown = (e) => {
    const rect = timelineDevices.getBoundingClientRect();
    const xPercent = (e.clientX - rect.left) / rect.width;
    const clickTime = new Date(STATE.startTime.getTime() + xPercent * durationMs);
    
    STATE.isDragging = false; // Don't assume drag until movement detected
    STATE.dragStartX = e.clientX;
    STATE.dragStartY = e.clientY;
    STATE.selectionStart = clickTime;
    STATE.selectionEnd = null;
    
    e.preventDefault(); // Prevent text selection
  };
  
  // Touch events for mobile
  timelineDevices.ontouchstart = (e) => {
    const touch = e.touches[0];
    const rect = timelineDevices.getBoundingClientRect();
    const xPercent = (touch.clientX - rect.left) / rect.width;
    const clickTime = new Date(STATE.startTime.getTime() + xPercent * durationMs);
    
    STATE.isDragging = false; // Don't assume drag until movement detected
    STATE.dragStartX = touch.clientX;
    STATE.dragStartY = touch.clientY;
    STATE.selectionStart = clickTime;
    STATE.selectionEnd = null;
    
    e.preventDefault(); // Prevent scrolling while dragging
  };
  
  timelineDevices.onmousemove = (e) => {
    const rect = timelineDevices.getBoundingClientRect();
    const xPercent = (e.clientX - rect.left) / rect.width;
    
    // Check if we should start dragging based on distance moved
    if (STATE.selectionStart && !STATE.isDragging && STATE.dragStartX !== null) {
      const dx = e.clientX - STATE.dragStartX;
      const dy = e.clientY - STATE.dragStartY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance > CONFIG.DRAG_THRESHOLD_PX) {
        STATE.isDragging = true;
      }
    }
    
    if (STATE.isDragging) {
      // Update selection end while dragging
      const currentTime = new Date(STATE.startTime.getTime() + xPercent * durationMs);
      STATE.selectionEnd = currentTime;
      
      // Draw selection visual
      const scrubber = document.getElementById('scrubber');
      if (scrubber) {
        const startPercent = ((STATE.selectionStart - STATE.startTime) / durationMs) * 100;
        const endPercent = ((STATE.selectionEnd - STATE.startTime) / durationMs) * 100;
        const left = Math.min(startPercent, endPercent);
        const width = Math.abs(endPercent - startPercent);
        
        scrubber.style.left = left + '%';
        scrubber.style.width = width + '%';
        scrubber.classList.add('visible');
        scrubber.classList.add('selecting');
      }
    } else if (!STATE.timelineLocked) {
      // Normal hover behavior
      const scrubber = document.getElementById('scrubber');
      if (scrubber) {
        scrubber.style.left = `${Math.min(Math.max(xPercent * 100, 0), 100)}%`;
        scrubber.style.width = '2px';
        scrubber.classList.remove('selecting');
        scrubber.classList.add('visible');
      }
      
      const hoverTime = new Date(STATE.startTime.getTime() + xPercent * durationMs);
      updateTimelineMarkers(hoverTime);
    }
  };
  
  timelineDevices.ontouchmove = (e) => {
    const touch = e.touches[0];
    const rect = timelineDevices.getBoundingClientRect();
    const xPercent = (touch.clientX - rect.left) / rect.width;
    
    // Check if we should start dragging based on distance moved
    if (STATE.selectionStart && !STATE.isDragging && STATE.dragStartX !== null) {
      const dx = touch.clientX - STATE.dragStartX;
      const dy = touch.clientY - STATE.dragStartY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance > CONFIG.DRAG_THRESHOLD_PX) {
        STATE.isDragging = true;
      }
    }
    
    if (STATE.isDragging) {
      // Update selection end while dragging
      const currentTime = new Date(STATE.startTime.getTime() + xPercent * durationMs);
      STATE.selectionEnd = currentTime;
      
      // Draw selection visual
      const scrubber = document.getElementById('scrubber');
      if (scrubber) {
        const startPercent = ((STATE.selectionStart - STATE.startTime) / durationMs) * 100;
        const endPercent = ((STATE.selectionEnd - STATE.startTime) / durationMs) * 100;
        const left = Math.min(startPercent, endPercent);
        const width = Math.abs(endPercent - startPercent);
        
        scrubber.style.left = left + '%';
        scrubber.style.width = width + '%';
        scrubber.classList.add('visible');
        scrubber.classList.add('selecting');
      }
      
      e.preventDefault(); // Prevent scrolling
    }
  };
  
  timelineDevices.onmouseup = (e) => {
    if (STATE.isDragging && STATE.selectionEnd) {
      const minTime = STATE.selectionStart < STATE.selectionEnd ? STATE.selectionStart : STATE.selectionEnd;
      const maxTime = STATE.selectionStart > STATE.selectionEnd ? STATE.selectionStart : STATE.selectionEnd;
      
      const selectionDuration = maxTime - minTime;
      const minSelectionMs = 5 * CONFIG.MS_PER_MINUTE; // Minimum 5 minute selection
      
      if (selectionDuration > minSelectionMs) {
        // Valid selection - zoom in by creating a custom time range
        
        // Only overwrite previousTimeRange if not already set
        if (!STATE.previousTimeRange) {
        // Save current state for reverting
          STATE.previousTimeRange = {
            mode: STATE.mode,
            startTime: new Date(STATE.startTime),
            endTime: new Date(STATE.endTime),
            isLiveMode: STATE.isLiveMode
          };
        }
        
        // Clear live interval if active
        if (STATE.liveInterval) {
          clearInterval(STATE.liveInterval);
          STATE.liveInterval = null;
        }
        
        // Switch to custom mode with zoomed range
        STATE.mode = 'custom';
        STATE.isLiveMode = false;
        STATE.startTime = minTime;
        STATE.endTime = maxTime;
        
        // Update the dropdown to show custom
        const timeRangeSelect = document.getElementById('time-range');
        if (timeRangeSelect) {
          timeRangeSelect.value = 'custom';
        }
        
        // Fetch data for this zoomed range
        fetchHistoryForRange(STATE.startTime.toISOString(), STATE.endTime.toISOString());
        
        updateTimelineButtons();
      } else {
        // Selection too small - treat as click to lock time
        const rect = timelineDevices.getBoundingClientRect();
        const xPercent = (e.clientX - rect.left) / rect.width;
        const clickTime = new Date(STATE.startTime.getTime() + xPercent * durationMs);
        
        STATE.timelineLocked = true;
        STATE.lockedTime = clickTime;
        
        const scrubber = document.getElementById('scrubber');
        if (scrubber) {
          scrubber.classList.add('locked');
          scrubber.classList.remove('selecting');
          scrubber.style.left = `${Math.min(Math.max(xPercent * 100, 0), 100)}%`;
          scrubber.style.width = '2px';
        }
        
        updateTimelineMarkers(clickTime, true);
        updateTimelineButtons();
      }
    }
    
    STATE.isDragging = false;
    STATE.dragStartX = null;
    STATE.dragStartY = null;
    STATE.selectionStart = null;
    STATE.selectionEnd = null;
  };
  
  timelineDevices.ontouchend = (e) => {
    if (STATE.isDragging) {
      if (STATE.selectionEnd) {
        const minTime = STATE.selectionStart < STATE.selectionEnd ? STATE.selectionStart : STATE.selectionEnd;
        const maxTime = STATE.selectionStart > STATE.selectionEnd ? STATE.selectionStart : STATE.selectionEnd;
        
        const selectionDuration = maxTime - minTime;
        const minSelectionMs = 5 * CONFIG.MS_PER_MINUTE; // Minimum 5 minute selection
        
        if (selectionDuration > minSelectionMs) {
          // Valid selection - zoom in by creating a custom time range
          
          // Only overwrite previousTimeRange if not already set
          if (!STATE.previousTimeRange) {          
            // Save current state for reverting
            STATE.previousTimeRange = {
              mode: STATE.mode,
              startTime: new Date(STATE.startTime),
              endTime: new Date(STATE.endTime),
              isLiveMode: STATE.isLiveMode
            };
          }
          
          // Clear live interval if active
          if (STATE.liveInterval) {
            clearInterval(STATE.liveInterval);
            STATE.liveInterval = null;
          }
          
          // Switch to custom mode with zoomed range
          STATE.mode = 'custom';
          STATE.isLiveMode = false;
          STATE.startTime = minTime;
          STATE.endTime = maxTime;
          
          // Update the dropdown to show custom
          const timeRangeSelect = document.getElementById('time-range');
          if (timeRangeSelect) {
            timeRangeSelect.value = 'custom';
          }
          
          // Fetch data for this zoomed range
          fetchHistoryForRange(STATE.startTime.toISOString(), STATE.endTime.toISOString());
          
          updateTimelineButtons();
        } else {
          // Selection too small - treat as tap to lock time
          const touch = e.changedTouches[0];
          const rect = timelineDevices.getBoundingClientRect();
          const xPercent = (touch.clientX - rect.left) / rect.width;
          const clickTime = new Date(STATE.startTime.getTime() + xPercent * durationMs);
          
          STATE.timelineLocked = true;
          STATE.lockedTime = clickTime;
          
          const scrubber = document.getElementById('scrubber');
          if (scrubber) {
            scrubber.classList.add('locked');
            scrubber.classList.remove('selecting');
            scrubber.style.left = `${Math.min(Math.max(xPercent * 100, 0), 100)}%`;
            scrubber.style.width = '2px';
          }
          
          updateTimelineMarkers(clickTime, true);
          updateTimelineButtons();
        }
      }
      
      STATE.isDragging = false;
      STATE.dragStartX = null;
      STATE.dragStartY = null;
      STATE.selectionStart = null;
      STATE.selectionEnd = null;
    }
  };

  timelineDevices.onmouseleave = () => {
    if (STATE.isDragging) {
      // Cancel drag if mouse leaves
      STATE.isDragging = false;
      STATE.selectionStart = null;
      STATE.selectionEnd = null;
    }
    
    if (STATE.timelineLocked) return;
    
    const scrubber = document.getElementById('scrubber');
    if (scrubber) {
      scrubber.classList.remove('visible', 'selecting');
      scrubber.style.width = '2px';
    }
    clearTimelineMarkers();
  };
  
  timelineDevices.ontouchcancel = () => {
    if (STATE.isDragging) {
      // Cancel drag if touch is interrupted
      STATE.isDragging = false;
      STATE.selectionStart = null;
      STATE.selectionEnd = null;
      
      const scrubber = document.getElementById('scrubber');
      if (scrubber) {
        scrubber.classList.remove('visible', 'selecting');
        scrubber.style.width = '2px';
      }
    }
  };
}

function drawTimeline() {
  const timelineDevices = document.getElementById('timeline-devices');
  const labelsColumn = document.getElementById('timeline-labels-column');
  const labelsContainer = document.getElementById('timeline-labels');
  
  if (!timelineDevices || !labelsColumn || !labelsContainer) {
    console.warn('Timeline elements not found');
    return;
  }
  
  // Clear previous content (except scrubber)
  const scrubber = document.getElementById('scrubber');
  timelineDevices.innerHTML = '';
  if (scrubber) {
    timelineDevices.appendChild(scrubber);
  }
  labelsColumn.innerHTML = '';
  labelsContainer.innerHTML = '';

  if (!STATE.startTime || !STATE.endTime) return;

  const durationMs = STATE.endTime - STATE.startTime;
  const durationHours = durationMs / CONFIG.MS_PER_HOUR;

  // Determine tick granularity
  let tickInterval, formatFn;
  
  if (durationHours <= 6) {
    tickInterval = CONFIG.MS_PER_HOUR;
    formatFn = (date) => date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  } else if (durationHours <= 24) {
    tickInterval = 4 * CONFIG.MS_PER_HOUR;
    formatFn = (date) => date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  } else if (durationHours <= 24 * 3) {
    tickInterval = 12 * CONFIG.MS_PER_HOUR;
    formatFn = (date) => date.toLocaleDateString([], { month: 'short', day: 'numeric' }) + ' ' + 
                        date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  } else if (durationHours <= 24 * 7) {
    tickInterval = CONFIG.MS_PER_DAY;
    formatFn = (date) => date.toLocaleDateString([], { month: 'short', day: 'numeric' });
  } else {
    const numTicks = 8;
    tickInterval = Math.ceil(durationMs / numTicks);
    formatFn = (date) => date.toLocaleDateString([], { month: 'short', day: 'numeric' });
  }

  const tickStart = STATE.startTime.getTime();
  const tickEnd = STATE.endTime.getTime();
  
  // Always add start label
  const startLabel = document.createElement('div');
  startLabel.className = 'timeline-tick-label first';
  startLabel.style.left = '0%';
  startLabel.textContent = formatFn(new Date(tickStart));
  labelsContainer.appendChild(startLabel);
  
  // Add intermediate ticks (skip if too close to start or end)
  for (let t = tickStart + tickInterval; t < tickEnd; t += tickInterval) {
    const xPercent = ((t - STATE.startTime) / durationMs) * 100;
    
    // Skip if too close to edges (to avoid overlap with start/end labels)
    if (xPercent < 8 || xPercent > 92) continue;
    
    const label = document.createElement('div');
    label.className = 'timeline-tick-label middle';
    label.style.left = xPercent + '%';
    label.textContent = formatFn(new Date(t));
    labelsContainer.appendChild(label);
  }
  
  // Always add end label
  const endLabel = document.createElement('div');
  endLabel.className = 'timeline-tick-label last';
  endLabel.style.left = '100%';
  endLabel.textContent = formatFn(new Date(tickEnd));
  labelsContainer.appendChild(endLabel);

  // Handle collapsed state - show amalgamated timeline
  if (STATE.isTimelineCollapsed) {
    labelsColumn.classList.add('collapsed');
    
    // Collect all movement segments from all devices
    const allSegments = [];
    Object.keys(DATA.movementSegments).forEach((deviceId) => {
      const segments = DATA.movementSegments[deviceId];
      segments.forEach(segment => {
        allSegments.push({ start: segment.start, end: segment.end });
      });
    });
    
    // Merge overlapping segments
    if (allSegments.length > 0) {
      allSegments.sort((a, b) => a.start - b.start);
      const merged = [allSegments[0]];
      
      for (let i = 1; i < allSegments.length; i++) {
        const current = allSegments[i];
        const last = merged[merged.length - 1];
        
        if (current.start <= last.end) {
          // Overlapping or adjacent, merge them
          last.end = new Date(Math.max(last.end.getTime(), current.end.getTime()));
        } else {
          // Non-overlapping, add as new segment
          merged.push(current);
        }
      }
      
      // Create amalgamated row
      const amalgamatedRow = document.createElement('div');
      amalgamatedRow.className = 'timeline-amalgamated-row visible';
      
      const tracksContainer = document.createElement('div');
      tracksContainer.className = 'timeline-device-tracks';
      
      merged.forEach(segment => {
        const startPercent = ((segment.start - STATE.startTime) / durationMs) * 100;
        const endPercent = ((segment.end - STATE.startTime) / durationMs) * 100;
        const widthPercent = endPercent - startPercent;
        
        if (widthPercent > 0) {
          const track = document.createElement('div');
          track.className = 'timeline-track';
          track.style.left = startPercent + '%';
          track.style.width = widthPercent + '%';
          track.style.background = '#999'; // Grey/colourless
          track.title = `Activity: ${segment.start.toLocaleString()} - ${segment.end.toLocaleString()}`;
          track.style.cursor = 'pointer';
          
          tracksContainer.appendChild(track);
        }
      });
      
      amalgamatedRow.appendChild(tracksContainer);
      timelineDevices.appendChild(amalgamatedRow);
    }
    
    // Set up interaction handlers for collapsed timeline
    setupTimelineInteraction(timelineDevices, durationMs);
    return;
  }
  
  // Expanded state - show individual device timelines
  labelsColumn.classList.remove('collapsed');

  // Draw movement tracks with device names in separate columns
  // Only show devices that have movement segments in the current time range
  const deviceIds = Object.keys(DATA.movementSegments);
  
  deviceIds.forEach((deviceId) => {
    const segments = DATA.movementSegments[deviceId];
    const isVisible = DATA.deviceVisibility[deviceId];
    
    // Create label in left column
    const nameLabel = document.createElement('div');
    nameLabel.className = 'timeline-device-name';
    if (!isVisible) {
      nameLabel.classList.add('disabled');
    }
    nameLabel.textContent = DATA.deviceNames[deviceId];
    nameLabel.style.color = DATA.deviceColors[deviceId];
    nameLabel.title = DATA.deviceNames[deviceId];
    nameLabel.dataset.deviceId = deviceId;
    
    // Timeline label click: Toggle visibility of marker and polyline on map
    nameLabel.onclick = () => {
      toggleDeviceVisibility(deviceId);
    };
    
    // Timeline label double-click: Show only this device
    nameLabel.ondblclick = (e) => {
      e.stopPropagation();
      // Hide all other devices
      if (STATE.soloDeviceId === deviceId) {
        // Already soloed - restore all devices
        Object.keys(DATA.deviceVisibility).forEach(id => {
          setDeviceVisibility(id, true);
        });
        STATE.soloDeviceId = null;
      } else {
        // Solo this device (hide all others)
        Object.keys(DATA.deviceVisibility).forEach(id => {
          setDeviceVisibility(id, id === deviceId);
        });
        STATE.soloDeviceId = deviceId;
      }
      updateLegend();
      updateTimelineAppearance();
    };
    
    labelsColumn.appendChild(nameLabel);
    
    // Create track row in right area - ALWAYS show tracks, regardless of visibility
    const trackRow = document.createElement('div');
    trackRow.className = 'timeline-device-row';
    
    const tracksContainer = document.createElement('div');
    tracksContainer.className = 'timeline-device-tracks';
    tracksContainer.dataset.deviceId = deviceId;
    if (!isVisible) {
      tracksContainer.classList.add('disabled');
    }

    segments.forEach(segment => {
      const startPercent = ((segment.start - STATE.startTime) / durationMs) * 100;
      const endPercent = ((segment.end - STATE.startTime) / durationMs) * 100;
      const widthPercent = endPercent - startPercent;
      
      if (widthPercent > 0) {
        const track = document.createElement('div');
        track.className = 'timeline-track';
        track.style.left = startPercent + '%';
        track.style.width = widthPercent + '%';
        track.style.background = DATA.deviceColors[deviceId];
        track.title = `${DATA.deviceNames[deviceId]}: ${segment.start.toLocaleString()} - ${segment.end.toLocaleString()}`;
        track.style.cursor = 'pointer';
        track.dataset.deviceId = deviceId; // Store deviceId on element
        
        // Disable interaction for hidden devices
        if (!isVisible) {
          track.style.pointerEvents = 'none';
          //track.style.opacity = '0.3';
        }
        
        // Timeline track click/touch: Focus on device at this point in time
        const handlePointerDown = (e) => {
          // Get deviceId from the actual element that was clicked
          const clickedDeviceId = e.currentTarget.dataset.deviceId;
          
          // Get coordinates from mouse or touch event
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const clientY = e.touches ? e.touches[0].clientY : e.clientY;
          
          const rect = timelineDevices.getBoundingClientRect();
          const xPercent = (clientX - rect.left) / rect.width;
          const clickTime = new Date(STATE.startTime.getTime() + xPercent * durationMs);
          
          STATE.isDragging = false; // Don't assume drag until movement exceeds threshold
          STATE.dragStartX = clientX;
          STATE.dragStartY = clientY;
          STATE.selectionStart = clickTime;
          STATE.selectionEnd = null;
          
          e.preventDefault();
          e.stopPropagation();
        };
        
        track.onmousedown = handlePointerDown;
        track.ontouchstart = handlePointerDown;
        
        const handleClick = (e) => {
          // Get deviceId from the actual element that was clicked
          const clickedDeviceId = e.currentTarget.dataset.deviceId;
          
          // Only focus on device if it was a click (not a drag)
          if (!STATE.isDragging && !STATE.selectionEnd) {
            e.stopPropagation();
            
            // Get coordinates from mouse or touch event
            const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            
            const rect = tracksContainer.getBoundingClientRect();
            const clickX = clientX - rect.left;
            const xPercent = clickX / rect.width;
            const clickTime = new Date(STATE.startTime.getTime() + xPercent * durationMs);
            
            // Use the deviceId from the clicked element, not the closure
            selectTimeOnTimeline(clickedDeviceId, clickTime);
          }
        };
        
        track.onclick = handleClick;
        track.ontouchend = handleClick;
        
        tracksContainer.appendChild(track);
      }
    });
    
    trackRow.appendChild(tracksContainer);
    timelineDevices.appendChild(trackRow);
  });

  // Set up interaction handlers
  setupTimelineInteraction(timelineDevices, durationMs);
  
  // Update timeline height for Leaflet controls positioning
  updateTimelineHeight();
}

function updateTimelineHeight() {
  // Use requestAnimationFrame to ensure DOM has updated
  requestAnimationFrame(() => {
    const timelineContainer = document.getElementById('timeline-container');
    if (timelineContainer) {
      const height = timelineContainer.offsetHeight;
      document.documentElement.style.setProperty('--timeline-height', `${height}px`);
    }
  });
}

function updateTimelineMarkers(time, locked = false) {
  if (!time) return;
  
  STATE.selectedTime = locked ? time : null;
  
  Object.keys(DATA.history).forEach(id => {
    if (!DATA.deviceVisibility[id]) return;
    
    const history = DATA.history[id];
    if (!history || history.length === 0) return;
    
    let closestPos = history[0];
    let minDiff = Math.abs(history[0].timestamp - time);
    
    for (const pos of history) {
      const diff = Math.abs(pos.timestamp - time);
      if (diff < minDiff) {
        minDiff = diff;
        closestPos = pos;
      }
    }
    
    if (DATA.tempMarkers[id]) {
      safeRemove(DATA.tempMarkers[id]);
    }
    
    const tempMarker = L.circleMarker(closestPos.coords, {
      radius: 6,
      color: DATA.deviceColors[id],
      fillColor: DATA.deviceColors[id],
      fillOpacity: 0.7,
      weight: 2
    }).addTo(map);

    bindPopupWithGeocode(tempMarker, id, closestPos);
    bindDeviceNameTooltip(tempMarker, id);

    if (locked) {
      tempMarker.openPopup();
    }
    
    DATA.tempMarkers[id] = tempMarker;
    
    if (DATA.markers[id] && map.hasLayer(DATA.markers[id])) {
      safeRemove(DATA.markers[id]);
    }
  });
  
  updateTimelineTitle();
}

function clearSelection() {
  STATE.selectedTime = null;
  STATE.timelineLocked = false;
  STATE.lockedTime = null;
  
  const scrubber = document.getElementById('scrubber');
  if (scrubber) {
    scrubber.classList.remove('locked', 'visible');
  }
  
  clearTimelineMarkers();
  updateTimelineTitle();
  updateTimelineButtons();
}

function updateTimelineButtons() {
  const actionBtn = document.getElementById('timeline-action-btn');
  
  if (!actionBtn) return;
  
  // Priority 1: If we have a previous time range (zoomed in), show "Back to Previous"
  if (STATE.previousTimeRange) {
    actionBtn.innerHTML  = '<i class="fa-solid fa-rotate-right"></i> Reset';
    actionBtn.style.display = 'inline-block';
  }
  // Priority 2: If timeline is locked (time selected), show "Clear Selection"
  else if (STATE.timelineLocked) {
    actionBtn.innerHTML = '<i class="fa-solid fa-times"></i> Clear';
    actionBtn.style.display = 'inline-block';
  }
  // Otherwise, hide the button
  else {
    actionBtn.style.display = 'none';
  }
}

function resetTimeline() {
  clearSelection();
  resetZoom();
  
  drawTimeline();
  updateTimelineTitle();
  updateTimelineButtons();
}

function clearTimelineMarkers() {
  Object.keys(DATA.tempMarkers).forEach(id => {
    if (DATA.tempMarkers[id]) {
      safeRemove(DATA.tempMarkers[id]);
      DATA.tempMarkers[id] = null;
    }
    if (DATA.markers[id] && !map.hasLayer(DATA.markers[id])) {
      DATA.markers[id].addTo(map);
    }
  });
  updateLegend([]);
}

function highlightTimelineForTime(deviceId, timestamp) {
  if (!STATE.startTime || !STATE.endTime) return;
  
  // Show scrubber at this timestamp position
  const scrubber = document.getElementById('scrubber');
  if (scrubber && !STATE.timelineLocked) {
    const durationMs = STATE.endTime - STATE.startTime;
    const xPercent = ((timestamp - STATE.startTime) / durationMs) * 100;
    scrubber.style.left = `${Math.min(Math.max(xPercent, 0), 100)}%`;
    scrubber.style.width = '2px';
    scrubber.classList.add('visible');
    scrubber.classList.remove('selecting');
  }
  
  // Find which timeline segment this time falls into
  const segments = DATA.movementSegments[deviceId];
  if (!segments) return;
  
  // Find the segment that contains this timestamp
  for (const segment of segments) {
    if (timestamp >= segment.start && timestamp <= segment.end) {
      // Find and highlight the corresponding track element
      const tracks = document.querySelectorAll('.timeline-track');
      tracks.forEach(track => {
        const title = track.title;
        // Check if this track belongs to this device and segment
        if (title.includes(DATA.deviceNames[deviceId]) && 
            title.includes(segment.start.toLocaleString())) {
          track.classList.add('highlighted');
        }
      });
      break;
    }
  }
}

function clearTimelineHighlight() {
  // Hide scrubber if not locked
  const scrubber = document.getElementById('scrubber');
  if (scrubber && !STATE.timelineLocked) {
    scrubber.classList.remove('visible');
  }
  
  // Clear highlighted tracks
  const tracks = document.querySelectorAll('.timeline-track.highlighted');
  tracks.forEach(track => {
    track.classList.remove('highlighted');
  });
}

function selectTimeOnTimeline(deviceId, timestamp) {
  const history = DATA.history[deviceId];
  if (!history || history.length === 0) return;
  
  // Find closest position to this timestamp
  let closestPos = history[0];
  let minDiff = Math.abs(history[0].timestamp - timestamp);
  
  for (const pos of history) {
    const diff = Math.abs(pos.timestamp - timestamp);
    if (diff < minDiff) {
      minDiff = diff;
      closestPos = pos;
    }
  }
  
  // Focus on this position
  centerMapWithPopup(closestPos.coords, 15);
  
  // Create/update temp marker at this position
  if (DATA.tempMarkers[deviceId]) {
    safeRemove(DATA.tempMarkers[deviceId]);
  }
  
  const tempMarker = L.circleMarker(closestPos.coords, {
    radius: 6,
    color: DATA.deviceColors[deviceId],
    fillColor: DATA.deviceColors[deviceId],
    fillOpacity: 0.7,
    weight: 2
  }).addTo(map);

  bindPopupWithGeocode(tempMarker, deviceId, closestPos);
  bindDeviceNameTooltip(tempMarker, deviceId);
  tempMarker.openPopup();

  DATA.tempMarkers[deviceId] = tempMarker;
  
  // Hide main marker temporarily
  if (DATA.markers[deviceId] && map.hasLayer(DATA.markers[deviceId])) {
    safeRemove(DATA.markers[deviceId]);
  }
  
  // Update scrubber position
  const scrubber = document.getElementById('scrubber');
  if (scrubber && STATE.startTime && STATE.endTime) {
    const durationMs = STATE.endTime - STATE.startTime;
    const timePercent = ((closestPos.timestamp - STATE.startTime) / durationMs) * 100;
    scrubber.style.left = `${Math.min(Math.max(timePercent, 0), 100)}%`;
    scrubber.style.width = '2px';
    scrubber.classList.add('locked', 'visible');
    scrubber.classList.remove('selecting');
  }
  
  STATE.timelineLocked = true;
  STATE.lockedTime = closestPos.timestamp;
  STATE.selectedTime = closestPos.timestamp;
  updateTimelineTitle();
  updateTimelineButtons();
}

function updateTimelineTitle() {
  const select = document.getElementById('time-range');
  const title = document.getElementById('timeline-title-center');
  
  if (!select || !title) {
    console.warn('Timeline title elements not found');
    return;
  }
  
  let titleText = '';
  
  if (STATE.selectedTime) {
    titleText = `Selected: ${STATE.selectedTime.toLocaleString([], { 
      month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit'
    })}`;
  } else if (STATE.mode === 'custom') {
    titleText = `${STATE.startTime.toLocaleString([], { 
      month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' 
    })}  ${STATE.endTime.toLocaleString([], { 
      month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' 
    })}`;
  } else {
    titleText = select.options[select.selectedIndex].text;
  }
  
  if (STATE.zoomLevel > 1) {
    titleText += ` (Zoomed)`;
  }
  
  title.textContent = titleText;
}

// ============================================================================
// EVENT LISTENERS
// ============================================================================

function setupEventListeners() {
  // Timeline action button (handles both clear selection and revert to previous)
  const actionBtn = document.getElementById('timeline-action-btn');
  if (actionBtn) {
    actionBtn.onclick = () => {
      // Priority 1: If we have a previous time range, revert to it
      if (STATE.previousTimeRange) {
        const prev = STATE.previousTimeRange;
        
        // Restore previous mode and time range
        STATE.mode = prev.mode;
        STATE.startTime = prev.startTime;
        STATE.endTime = prev.endTime;
        STATE.isLiveMode = prev.isLiveMode;
        STATE.previousTimeRange = null;
        
        // Clear selection when reverting
        clearSelection();
        
        // Update dropdown
        const timeRangeSelect = document.getElementById('time-range');
        if (timeRangeSelect) {
          timeRangeSelect.value = STATE.mode;
        }
        
        // Restart live interval if needed
        if (STATE.isLiveMode && !STATE.liveInterval) {
          STATE.liveInterval = setInterval(fetchLive, CONFIG.POLL_INTERVAL_MS);
        }
        
        // Re-fetch data for previous range
        fetchHistoryForRange(STATE.startTime.toISOString(), STATE.endTime.toISOString());
        
        updateTimelineButtons();
      }
      // Priority 2: Clear selection if timeline is locked
      else if (STATE.timelineLocked) {
        clearSelection();
      }
    };
  }

  const collapseBtn = document.getElementById('timeline-collapse-btn');
  if (collapseBtn) {
    collapseBtn.onclick = () => {
      STATE.isTimelineCollapsed = !STATE.isTimelineCollapsed;
      
      if (STATE.isTimelineCollapsed) {
        collapseBtn.innerHTML = '<i class="fa-solid fa-caret-up"></i>';
      } else {
        collapseBtn.innerHTML = '<i class="fa-solid fa-caret-down"></i> ';
      }
      updateTimelineHeight();
      drawTimeline();
    };
  }

  const legendToggleBtn = document.getElementById('legend-toggle-btn');
  const legend = document.getElementById('legend');
  if (legendToggleBtn && legend) {
    legendToggleBtn.onclick = () => {
      STATE.isLegendCollapsed = !STATE.isLegendCollapsed;

      if (STATE.isLegendCollapsed) {
        legendToggleBtn.innerHTML = '<i class="fa-regular fa-rectangle-list"></i>';
        legend.classList.add('collapsed');
      } else {
        legendToggleBtn.innerHTML = '<i class="fa-solid fa-map"></i>';
        legend.classList.remove('collapsed');
      }
    };
  }

  // Device search filtering and focus behavior
  const legendSearch = document.getElementById('legend-search');
  if (legendSearch) {
    // On focus: expand legend to show items
    legendSearch.addEventListener('focus', () => {
      if (STATE.isLegendCollapsed) {
        STATE.isLegendCollapsed = false;
        legendToggleBtn.innerHTML = '<i class="fa-solid fa-map"></i>';
        legend.classList.remove('collapsed');
      }
    });

    // Filter items as user types
    legendSearch.addEventListener('input', (e) => {
      const searchTerm = e.target.value.toLowerCase().trim();
      const legendItems = document.querySelectorAll('.legend-item');

      legendItems.forEach(item => {
        const deviceName = item.dataset.deviceName || '';
        const deviceStatus = item.dataset.status || '';

        // Match against device name or status
        const matches = deviceName.includes(searchTerm) ||
                       deviceStatus.includes(searchTerm);

        item.style.display = matches ? '' : 'none';
      });
    });

    // Escape key: collapse legend
    legendSearch.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        e.preventDefault();
        legendSearch.blur();
        if (!STATE.isLegendCollapsed) {
          STATE.isLegendCollapsed = true;
          legendToggleBtn.innerHTML = '<i class="fa-regular fa-rectangle-list"></i>';
          legend.classList.add('collapsed');
        }
      }
    });
  }

  // Click outside legend: collapse legend (only if search has been focused)
  let searchWasFocused = false;
  if (legendSearch) {
    legendSearch.addEventListener('focus', () => {
      searchWasFocused = true;
    });
  }

  document.addEventListener('click', (e) => {
    if (!legend || !legendSearch) return;

    // Don't collapse if legend is already collapsed
    if (STATE.isLegendCollapsed) return;

    // Don't collapse if clicking inside legend
    if (legend.contains(e.target)) return;

    // Only collapse if search was previously focused (user initiated the expansion)
    if (searchWasFocused && !STATE.isLegendCollapsed) {
      STATE.isLegendCollapsed = true;
      legendToggleBtn.innerHTML = '<i class="fa-regular fa-rectangle-list"></i>';
      legend.classList.add('collapsed');
      searchWasFocused = false;
    }
  });

  // Move time selector to legend on mobile
  let timeSelectorOriginalParent = null;
  let timeSelectorOriginalNextSibling = null;

  function setupMobileLayout() {
    const timeSelector = document.getElementById('time-selector');
    const legendHeader = document.querySelector('.legend-header');
    const app = document.getElementById('app');

    if (!timeSelector || !legendHeader || !app) return;

    if (window.innerWidth <= 768) {
      // Mobile: Move time selector into legend header
      if (timeSelector.parentElement !== legendHeader) {
        // Store original position for restoration
        timeSelectorOriginalParent = timeSelector.parentElement;
        timeSelectorOriginalNextSibling = timeSelector.nextSibling;

        // Move it into legend header
        legendHeader.appendChild(timeSelector);
      }
    } else {
      // Desktop: Move time selector back to original position
      if (timeSelectorOriginalParent && timeSelector.parentElement === legendHeader) {
        if (timeSelectorOriginalNextSibling) {
          timeSelectorOriginalParent.insertBefore(timeSelector, timeSelectorOriginalNextSibling);
        } else {
          timeSelectorOriginalParent.appendChild(timeSelector);
        }
      }
    }
  }

  // Setup mobile layout on load and resize
  setupMobileLayout();
  window.addEventListener('resize', setupMobileLayout);

  const settingsBtn = document.getElementById('settings-btn');
  const settingsModal = document.getElementById('settings-modal');
  if (settingsBtn && settingsModal) {
    settingsBtn.onclick = () => {
      settingsModal.style.display = 'flex';
      document.body.classList.add('modal-open');
    };
  }

  const closeSettings = document.getElementById('close-settings');
  if (closeSettings && settingsModal) {
    closeSettings.onclick = () => {
      settingsModal.style.display = 'none';
      document.body.classList.remove('modal-open');
    };
  }

  const themeSelect = document.getElementById('theme-select');
  if (themeSelect) {
    themeSelect.onchange = function() {
      applyTheme(this.value);
    };
  }

  // Settings color pickers
  const foregroundColorInput = document.getElementById('foreground-color');
  const foregroundColorTextInput = document.getElementById('foreground-color-text');
  const backgroundColorInput = document.getElementById('background-color');
  const backgroundColorTextInput = document.getElementById('background-color-text');
  
  if (foregroundColorInput && foregroundColorTextInput) {
    foregroundColorInput.addEventListener('change', (e) => {
      CONFIG.FOREGROUND_COLOR = e.target.value;
      foregroundColorTextInput.value = e.target.value;
      saveSettings();
    });
    foregroundColorTextInput.addEventListener('change', (e) => {
      if (/^#[0-9A-F]{6}$/i.test(e.target.value)) {
        CONFIG.FOREGROUND_COLOR = e.target.value;
        foregroundColorInput.value = e.target.value;
        saveSettings();
      }
    });
  }
  
  if (backgroundColorInput && backgroundColorTextInput) {
    backgroundColorInput.addEventListener('change', (e) => {
      CONFIG.BACKGROUND_COLOR = e.target.value;
      backgroundColorTextInput.value = e.target.value;
      saveSettings();
    });
    backgroundColorTextInput.addEventListener('change', (e) => {
      if (/^#[0-9A-F]{6}$/i.test(e.target.value)) {
        CONFIG.BACKGROUND_COLOR = e.target.value;
        backgroundColorInput.value = e.target.value;
        saveSettings();
      }
    });
  }

  // API settings
  const apiUrlInput = document.getElementById('api-url');
  const apiUsernameInput = document.getElementById('api-username');
  const apiPasswordInput = document.getElementById('api-password');
  const pollIntervalInput = document.getElementById('poll-interval');
  const movementThresholdInput = document.getElementById('movement-threshold');
  
  if (apiUrlInput) {
    apiUrlInput.addEventListener('change', (e) => {
      CONFIG.API_URL = e.target.value;
      saveSettings();
    });
  }
  
  if (apiUsernameInput) {
    apiUsernameInput.addEventListener('change', (e) => {
      CONFIG.API_USERNAME = e.target.value;
      saveSettings();
    });
  }
  
  if (apiPasswordInput) {
    apiPasswordInput.addEventListener('change', (e) => {
      CONFIG.API_PASSWORD = e.target.value;
      saveSettings();
    });
  }
  
  if (pollIntervalInput) {
    pollIntervalInput.addEventListener('change', (e) => {
      CONFIG.POLL_INTERVAL_MS = parseInt(e.target.value);
      saveSettings();
    });
  }
  
  if (movementThresholdInput) {
    movementThresholdInput.addEventListener('change', (e) => {
      CONFIG.MOVEMENT_THRESHOLD_M = parseInt(e.target.value);
      saveSettings();
    });
  }

  // Realtime hours
  const realtimeHoursInput = document.getElementById('realtime-hours');
  if (realtimeHoursInput) {
    realtimeHoursInput.addEventListener('change', (e) => {
      CONFIG.REALTIME_HISTORY_HOURS = parseInt(e.target.value);
      saveSettings();
      // Update the dropdown text
      const timeRangeSelect = document.getElementById('time-range');
      if (timeRangeSelect) {
        const realtimeOption = timeRangeSelect.querySelector('option[value="realtime"]');
        if (realtimeOption) {
          realtimeOption.textContent = `Real Time +${CONFIG.REALTIME_HISTORY_HOURS}h`;
        }
      }
    });
  }

  // Show direction arrows checkbox
  const showDirectionArrowsInput = document.getElementById('show-direction-arrows');
  if (showDirectionArrowsInput) {
    showDirectionArrowsInput.addEventListener('change', (e) => {
      CONFIG.SHOW_DIRECTION_ARROWS = e.target.checked;
      saveSettings();

      // Update all trail decorators (will add or remove based on new setting)
      Object.keys(DATA.deviceVisibility).forEach(deviceId => {
        updateTrailDecorator(deviceId);
      });
    });
  }

  // Arrow spacing slider
  const arrowSpacingInput = document.getElementById('arrow-spacing');
  const arrowSpacingValue = document.getElementById('arrow-spacing-value');
  if (arrowSpacingInput && arrowSpacingValue) {
    arrowSpacingInput.addEventListener('input', (e) => {
      const value = parseInt(e.target.value);
      arrowSpacingValue.textContent = value;
      CONFIG.ARROW_REPEAT_PIXELS = value;
      saveSettings();

      // Update all trail decorators with new spacing
      Object.keys(DATA.deviceVisibility).forEach(deviceId => {
        updateTrailDecorator(deviceId);
      });
    });
  }

  // Palette manager
  const addPaletteBtn = document.getElementById('add-palette-color');
  if (addPaletteBtn) {
    addPaletteBtn.addEventListener('click', () => {
      CONFIG.PALETTE.push('#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0').toUpperCase());
      saveSettings();
      renderPaletteManager();
    });
  }

  // Color editor modal
  const saveColorBtn = document.getElementById('save-color');
  const deleteColorBtn = document.getElementById('delete-color');
  const cancelColorBtn = document.getElementById('cancel-color');
  const colorHexInput = document.getElementById('color-hex-input');
  const colorPickerInput = document.getElementById('color-picker-input');
  const colorEditorModal = document.getElementById('color-editor-modal');
  
  if (saveColorBtn) {
    saveColorBtn.addEventListener('click', saveColorEdit);
  }
  
  if (deleteColorBtn) {
    deleteColorBtn.addEventListener('click', deleteColorEdit);
  }
  
  if (cancelColorBtn) {
    cancelColorBtn.addEventListener('click', closeColorEditor);
  }
  
  // Color picker input - update hex input and preview
  if (colorPickerInput) {
    colorPickerInput.addEventListener('input', (e) => {
      const preview = document.getElementById('color-preview');
      const hexInput = document.getElementById('color-hex-input');
      const value = e.target.value.toUpperCase();
      
      if (hexInput) {
        hexInput.value = value;
      }
      if (preview) {
        preview.style.backgroundColor = value;
      }
    });
  }
  
  // Hex input - update color picker and preview
  if (colorHexInput) {
    colorHexInput.addEventListener('input', (e) => {
      const preview = document.getElementById('color-preview');
      const picker = document.getElementById('color-picker-input');
      const value = e.target.value.trim();
      
      if (/^#[0-9A-F]{6}$/i.test(value)) {
        if (preview) {
          preview.style.backgroundColor = value;
        }
        if (picker) {
          picker.value = value;
        }
      }
    });
    
    colorHexInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        saveColorEdit();
      } else if (e.key === 'Escape') {
        closeColorEditor();
      }
    });
  }
  
  if (colorEditorModal) {
    colorEditorModal.addEventListener('click', (e) => {
      if (e.target.id === 'color-editor-modal') {
        closeColorEditor();
      }
    });
  }

  // Import/Export
  const exportBtn = document.getElementById('export-settings');
  const importBtn = document.getElementById('import-settings');
  const importFileInput = document.getElementById('import-file-input');
  
  if (exportBtn) {
    exportBtn.addEventListener('click', exportSettings);
  }
  
  if (importBtn && importFileInput) {
    importBtn.addEventListener('click', () => {
      importFileInput.click();
    });
    importFileInput.addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        importSettings(e.target.files[0]);
        e.target.value = ''; // Reset file input
      }
    });
  }

  if (settingsModal) {
    settingsModal.onclick = (e) => {
      if (e.target.id === 'settings-modal') {
        settingsModal.style.display = 'none';
        document.body.classList.remove('modal-open');
      }
    };
  }

  const timeRange = document.getElementById('time-range');
  const customDiv = document.getElementById('custom-time');
  const changeTimeBtn = document.getElementById('change-time-btn');
  
  if (timeRange) {
    timeRange.onchange = function() {
      if (STATE.liveInterval) {
        clearInterval(STATE.liveInterval);
        STATE.liveInterval = null;
      }
      
      STATE.mode = this.value;

      // Clear any previous time range when manually changing modes
      STATE.previousTimeRange = null;
      clearSelection();
      resetZoom();

      // Reset all device visibility to true when changing time ranges
      Object.keys(DATA.deviceVisibility).forEach(id => {
        DATA.deviceVisibility[id] = true;
      });
      STATE.soloDeviceId = null;

      if (this.value === 'custom') {
        if (customDiv) customDiv.style.display = 'block';
        if (changeTimeBtn) changeTimeBtn.style.display = 'inline-block';
        STATE.isLiveMode = false;
        return;
      }
      
      if (customDiv) customDiv.style.display = 'none';
      if (changeTimeBtn) changeTimeBtn.style.display = 'none';
      
      if (this.value === 'realtime') {
        STATE.isLiveMode = true;
        const now = new Date();
        const from = new Date(now.getTime() - CONFIG.REALTIME_HISTORY_HOURS * CONFIG.MS_PER_HOUR);
        fetchHistoryForRange(from.toISOString(), now.toISOString());

        // Initialize last fetch time for gap detection
        STATE.lastFetchTime = new Date();

        STATE.liveInterval = setInterval(fetchLive, CONFIG.POLL_INTERVAL_MS);
      } else {
        STATE.isLiveMode = false;
        
        const now = new Date();
        let from, to = now;
        
        switch (this.value) {
          case 'today':
            from = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0);
            break;
          case 'yesterday':
            from = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1, 0, 0, 0);
            to = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0);
            break;
          case 'week':
            from = new Date(now.getFullYear(), now.getMonth(), now.getDate() - now.getDay(), 0, 0, 0);
            break;
          case 'month':
            from = new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0);
            break;
          default:
            from = new Date(now.getTime() - CONFIG.MS_PER_DAY);
        }
        
        fetchHistoryForRange(from.toISOString(), to.toISOString());
      }
    };
  }

  if (changeTimeBtn && customDiv) {
    changeTimeBtn.onclick = () => {
      customDiv.style.display = customDiv.style.display === 'none' ? 'block' : 'none';
    };
  }

  const customApply = document.getElementById('custom-apply');
  const customCancel = document.getElementById('cancel-custom');
  const customFrom = document.getElementById('custom-from');
  const customTo = document.getElementById('custom-to');
  
  if (customApply && customFrom && customTo) {
    customCancel.onclick = () => {
      if (customDiv) {
        customDiv.style.display = 'none';
      }
    };

    customApply.onclick = () => {
      const fromVal = customFrom.value;
      const toVal = customTo.value;
      
      if (!fromVal || !toVal) {
        alert('Please select both from and to dates');
        return;
      }

      if (STATE.liveInterval) {
        clearInterval(STATE.liveInterval);
        STATE.liveInterval = null;
      }
      
      STATE.isLiveMode = false;
      const from = new Date(fromVal);
      const to = new Date(toVal);
      
      if (from >= to) {
        alert('From date must be before To date');
        return;
      }

      fetchHistoryForRange(from.toISOString(), to.toISOString());
      if (customDiv) {
        customDiv.style.display = 'none';
      }
    };
  }
}

function setupDateInputs() {
  const fromInput = document.getElementById('custom-from');
  const toInput = document.getElementById('custom-to');
  
  if (!fromInput || !toInput) {
    console.warn('Date input elements not found');
    return;
  }
  
  fromInput.addEventListener('change', () => {
    if (!toInput.value && fromInput.value) {
      const from = new Date(fromInput.value);
      const to = new Date(from.getTime() + CONFIG.MS_PER_DAY);
      to.setHours(23, 59, 0, 0);
      toInput.value = formatDateTimeLocal(to);
    }
  });
  
  toInput.addEventListener('change', () => {
    if (!fromInput.value && toInput.value) {
      const to = new Date(toInput.value);
      const from = new Date(to.getTime() - CONFIG.MS_PER_DAY);
      from.setHours(0, 0, 0, 0);
      fromInput.value = formatDateTimeLocal(from);
    }
  });
}

function resetZoom() {
  STATE.zoomStartTime = null;
  STATE.zoomEndTime = null;
  STATE.zoomLevel = 1;
  STATE.previousTimeRange = null;
  clearSelection();
  updateTimelineButtons();
  drawTimeline();
}

// ============================================================================
// INITIALIZATION
// ============================================================================

async function init() {
  try {
    loadTheme();
    loadSettings(); // Load saved settings
    
    if (typeof L === 'undefined') {
      throw new Error('Leaflet library failed to load');
    }
    
    initMap();
    
    // Set up event listeners BEFORE fetching data so settings button always works
    setupEventListeners();
    updateSettingsUI(); 
    setupDateInputs();
    
    // Set the real-time option text dynamically based on config
    const timeRangeSelect = document.getElementById('time-range');
    if (timeRangeSelect) {
      const realtimeOption = timeRangeSelect.querySelector('option[value="realtime"]');
      if (realtimeOption) {
        realtimeOption.textContent = `Real Time +${CONFIG.REALTIME_HISTORY_HOURS}h`;
      }
    }
   
    // Initial timeline height update
    updateTimelineHeight();
 
    // Now fetch devices - if this fails, settings button still works
    await fetchDevices();
    
    STATE.mode = 'realtime';
    STATE.isLiveMode = true;
    
    const now = new Date();
    const from = new Date(now.getTime() - CONFIG.REALTIME_HISTORY_HOURS * CONFIG.MS_PER_HOUR);
    
    await fetchHistoryForRange(from.toISOString(), now.toISOString());

    // Initialize last fetch time for gap detection
    STATE.lastFetchTime = new Date();

    STATE.liveInterval = setInterval(fetchLive, CONFIG.POLL_INTERVAL_MS);
    
    STATE.legendUpdateInterval = setInterval(() => {
      updateLegend();
    }, 10 * CONFIG.MS_PER_SECOND);
  } catch (err) {
    console.error('Initialization error:', err);
    showError(`Application failed to initialize: ${err.message}<br><br>Please refresh the page or check the console for details.`, true);
    
    const retryBtn = document.getElementById('retry-btn');
    if (retryBtn) {
      retryBtn.onclick = async () => {
        retryBtn.disabled = true; 
        retryBtn.textContent = 'Retrying...'; 

        await sleep(800);

        const errorModal = document.getElementById('error-modal');
        if (errorModal) {
          errorModal.remove();
        }

        await sleep(200); 

        location.reload();
      };
    }
  }
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}
</script>

</body>
</html>
